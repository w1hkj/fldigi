// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include "gettext.h"
#include "confdialog.h"
#include <config.h>
#include <FL/Fl_Tooltip.H>
#include <FL/filename.H>
#include "main.h"
#include "fl_digi.h"
#include "soundconf.h"
#include "colorsfonts.h"
#include "waterfall.h"
#include "rigxml.h"
#include "lookupcall.h"
#include "icons.h"
#include "Viewer.h"
#include "pskrep.h"
#include "logsupport.h"
#include "notify.h"
#include "debug.h"
#include "status.h"
#include "rx_extract.h"
#if USE_HAMLIB
  #include "hamlib.h"
#endif
Fl_Double_Window *dlgConfig; 
Mode_Browser* mode_browser; 

void set_qrz_buttons(Fl_Button* b) {
  Fl_Button* qrzb[] = { btnQRZnotavailable, btnQRZcdrom, btnQRZonline,
                              btnQRZsub, btnHamcall, btnHAMCALLonline,
                              btnCALLOOK};

for (size_t i = 0; i < sizeof(qrzb)/sizeof(*qrzb); i++)
	qrzb[i]->value(b == qrzb[i]);
}

Fl_Tabs *tabsConfigure=(Fl_Tabs *)0;

Fl_Group *tabOperator=(Fl_Group *)0;

static void cb_tabOperator(Fl_Group*, void*) {
  progdefaults.changed = true;
}

Fl_Input2 *inpMyCallsign=(Fl_Input2 *)0;

static void cb_inpMyCallsign(Fl_Input2* o, void*) {
  if (progdefaults.THORsecText.empty()) {
progdefaults.THORsecText = o->value();
progdefaults.THORsecText.append(" ");
txtTHORSecondary->value(progdefaults.THORsecText.c_str());
}
if (progdefaults.secText.empty()) {
progdefaults.secText = o->value();
progdefaults.secText.append(" ");
txtSecondary->value(progdefaults.secText.c_str());
}
progdefaults.myCall = o->value();
update_main_title();
notify_change_callsign();
progdefaults.changed = true;
}

Fl_Input2 *inpMyName=(Fl_Input2 *)0;

static void cb_inpMyName(Fl_Input2* o, void*) {
  progdefaults.myName = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpMyQth=(Fl_Input2 *)0;

static void cb_inpMyQth(Fl_Input2* o, void*) {
  progdefaults.myQth = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpMyLocator=(Fl_Input2 *)0;

static void cb_inpMyLocator(Fl_Input2* o, void*) {
  progdefaults.myLocator = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpMyAntenna=(Fl_Input2 *)0;

static void cb_inpMyAntenna(Fl_Input2* o, void*) {
  progdefaults.myAntenna = o->value();
progdefaults.changed = true;
}

Fl_Group *grpNoise=(Fl_Group *)0;

Fl_Check_Button *btnNoiseOn=(Fl_Check_Button *)0;

static void cb_btnNoiseOn(Fl_Check_Button* o, void*) {
  progdefaults.noise = o->value();
}

Fl_Counter2 *noiseDB=(Fl_Counter2 *)0;

static void cb_noiseDB(Fl_Counter2* o, void*) {
  progdefaults.s2n = o->value();
}

Fl_Group *tabUI=(Fl_Group *)0;

Fl_Tabs *tabsUI=(Fl_Tabs *)0;

Fl_Group *tabUserInterface=(Fl_Group *)0;

Fl_Check_Button *btnShowTooltips=(Fl_Check_Button *)0;

static void cb_btnShowTooltips(Fl_Check_Button* o, void*) {
  progdefaults.tooltips = o->value();
Fl_Tooltip::enable(progdefaults.tooltips);
progdefaults.changed = true;
}

Fl_Check_Button *chkMenuIcons=(Fl_Check_Button *)0;

static void cb_chkMenuIcons(Fl_Check_Button* o, void*) {
  progdefaults.menuicons = o->value();
toggle_icon_labels();
progdefaults.changed = true;
}

Fl_Choice *mnuScheme=(Fl_Choice *)0;

static void cb_mnuScheme(Fl_Choice* o, void*) {
  progdefaults.ui_scheme = o->text();
    Fl::scheme(progdefaults.ui_scheme.c_str());

    progdefaults.changed = true;
}

Fl_Button *bVisibleModes=(Fl_Button *)0;

static void cb_bVisibleModes(Fl_Button* o, void*) {
  mode_browser->label(o->label());
mode_browser->callback(toggle_visible_modes);
mode_browser->show(&progdefaults.visible_modes);
progdefaults.changed = true;
}

Fl_Choice *mnuLang=(Fl_Choice *)0;

static void cb_mnuLang(Fl_Choice* o, void*) {
  progdefaults.ui_language = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnNagMe=(Fl_Check_Button *)0;

static void cb_btnNagMe(Fl_Check_Button* o, void*) {
  progdefaults.NagMe=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnClearOnSave=(Fl_Check_Button *)0;

static void cb_btnClearOnSave(Fl_Check_Button* o, void*) {
  progdefaults.ClearOnSave=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnAutoFillQSO=(Fl_Check_Button *)0;

static void cb_btnAutoFillQSO(Fl_Check_Button* o, void*) {
  progdefaults.autofill_qso_fields = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCallUpperCase=(Fl_Check_Button *)0;

static void cb_btnCallUpperCase(Fl_Check_Button* o, void*) {
  progdefaults.calluppercase = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDateTimeSort=(Fl_Check_Button *)0;

static void cb_btnDateTimeSort(Fl_Check_Button* o, void*) {
  progdefaults.sort_date_time_off = o->value();
progdefaults.changed = true;
reload_browser();
}

Fl_Check_Button *btndate_time_force=(Fl_Check_Button *)0;

static void cb_btndate_time_force(Fl_Check_Button* o, void*) {
  progdefaults.force_date_time = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpMyPower=(Fl_Input2 *)0;

static void cb_inpMyPower(Fl_Input2* o, void*) {
  progdefaults.mytxpower = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnRSTdefault=(Fl_Check_Button *)0;

static void cb_btnRSTdefault(Fl_Check_Button* o, void*) {
  progdefaults.RSTdefault = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnRXClicks=(Fl_Check_Button *)0;

static void cb_btnRXClicks(Fl_Check_Button* o, void*) {
  progdefaults.rxtext_clicks_qso_data = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnRXTooltips=(Fl_Check_Button *)0;

static void cb_btnRXTooltips(Fl_Check_Button* o, void*) {
  progdefaults.rxtext_tooltips = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpNonword=(Fl_Input2 *)0;

static void cb_inpNonword(Fl_Input2* o, void*) {
  progdefaults.nonwordchars = o->value();
progdefaults.changed = true;
}

Fl_Group *tabBrowser=(Fl_Group *)0;

Fl_Spinner2 *cntChannels=(Fl_Spinner2 *)0;

static void cb_cntChannels(Fl_Spinner2* o, void*) {
  progdefaults.VIEWERchannels = (int)(o->value());
initViewer();
}

Fl_Spinner2 *cntTimeout=(Fl_Spinner2 *)0;

static void cb_cntTimeout(Fl_Spinner2* o, void*) {
  progdefaults.VIEWERtimeout = (int)(o->value());
progdefaults.changed = true;
}

Fl_Choice *mnuViewerLabel=(Fl_Choice *)0;

static void cb_mnuViewerLabel(Fl_Choice* o, void*) {
  progdefaults.VIEWERlabeltype = o->value();
initViewer();
progdefaults.changed = true;
}

Fl_Button *btnViewerFont=(Fl_Button *)0;

static void cb_btnViewerFont(Fl_Button*, void*) {
  font_browser->fontNumber(progdefaults.ViewerFontnbr);
font_browser->fontSize(progdefaults.ViewerFontsize);
font_browser->fontColor(FL_FOREGROUND_COLOR);
font_browser->fontFilter(Font_Browser::FIXED_WIDTH);
font_browser->callback(cbViewerFontBrowser);
font_browser->show();
}

Fl_Check_Button *btnFixedIntervals=(Fl_Check_Button *)0;

static void cb_btnFixedIntervals(Fl_Check_Button* o, void*) {
  progdefaults.VIEWERfixed = o->value();
progdefaults.changed = true;
initViewer();
}

Fl_Check_Button *btnMarquee=(Fl_Check_Button *)0;

static void cb_btnMarquee(Fl_Check_Button* o, void*) {
  progdefaults.VIEWERmarquee = o->value();
progdefaults.changed = true;
initViewer();
}

Fl_Check_Button *btnAscend=(Fl_Check_Button *)0;

static void cb_btnAscend(Fl_Check_Button* o, void*) {
  progdefaults.VIEWERascend = o->value();
progdefaults.changed = true;
initViewer();
}

Fl_Check_Button *btnBrowserHistory=(Fl_Check_Button *)0;

static void cb_btnBrowserHistory(Fl_Check_Button* o, void*) {
  progdefaults.VIEWERhistory = o->value();
progdefaults.changed = true;
}

Fl_Button *bwsrSliderColor=(Fl_Button *)0;

static void cb_bwsrSliderColor(Fl_Button* o, void*) {
  uchar r, g, b;
    r = progdefaults.bwsrSliderColor.R;
    g = progdefaults.bwsrSliderColor.G;
    b = progdefaults.bwsrSliderColor.B;

    if (fl_color_chooser("Slider Color", r, g, b) == 0)
        return;
    progdefaults.bwsrSliderColor.R = r;
    progdefaults.bwsrSliderColor.G = g;
    progdefaults.bwsrSliderColor.B = b;
    o->color(fl_rgb_color(r,g,b));
    o->redraw();
    sldrViewerSquelch->color(fl_rgb_color(r,g,b));
    sldrViewerSquelch->redraw();
    mvsquelch->color(fl_rgb_color(r,g,b));
    mvsquelch->redraw();
    
    progdefaults.changed = true;
}

Fl_Button *bwsrSldrSelColor=(Fl_Button *)0;

static void cb_bwsrSldrSelColor(Fl_Button* o, void*) {
  uchar r, g, b;
    r = progdefaults.bwsrSldrSelColor.R;
    g = progdefaults.bwsrSldrSelColor.G;
    b = progdefaults.bwsrSldrSelColor.B;

    if (fl_color_chooser("Button Color", r, g, b) == 0)
        return;
    progdefaults.bwsrSldrSelColor.R = r;
    progdefaults.bwsrSldrSelColor.G = g;
    progdefaults.bwsrSldrSelColor.B = b;
    o->color(fl_rgb_color(r,g,b));
    o->redraw();
    sldrViewerSquelch->selection_color(fl_rgb_color(r,g,b));
    sldrViewerSquelch->redraw();
    mvsquelch->selection_color(fl_rgb_color(r,g,b));
    mvsquelch->redraw();
    
    progdefaults.changed = true;
}

Fl_Group *tabMBars=(Fl_Group *)0;

Fl_Check_Button *btnMacroMouseWheel=(Fl_Check_Button *)0;

static void cb_btnMacroMouseWheel(Fl_Check_Button* o, void*) {
  progdefaults.macro_wheel = o->value();
progdefaults.changed = true;
}

Fl_Round_Button *btn_oneA=(Fl_Round_Button *)0;

static void cb_btn_oneA(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 0;
progdefaults.mbar1_pos = true;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_oneB=(Fl_Round_Button *)0;

static void cb_btn_oneB(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 0;
progdefaults.mbar1_pos = false;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_twoA=(Fl_Round_Button *)0;

static void cb_btn_twoA(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 1;
progdefaults.mbar1_pos = true;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_twoB=(Fl_Round_Button *)0;

static void cb_btn_twoB(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 2;
progdefaults.mbar1_pos = true;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_twoC=(Fl_Round_Button *)0;

static void cb_btn_twoC(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 3;
progdefaults.mbar1_pos = true;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_twoD=(Fl_Round_Button *)0;

static void cb_btn_twoD(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 1;
progdefaults.mbar1_pos = false;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_twoE=(Fl_Round_Button *)0;

static void cb_btn_twoE(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 2;
progdefaults.mbar1_pos = false;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Round_Button *btn_twoF=(Fl_Round_Button *)0;

static void cb_btn_twoF(Fl_Round_Button*, void*) {
  progdefaults.mbar2_pos = 3;
progdefaults.mbar1_pos = false;
progdefaults.changed = true;
set_macroLabels();
UI_select();
}

Fl_Check_Button *btnUseLastMacro=(Fl_Check_Button *)0;

static void cb_btnUseLastMacro(Fl_Check_Button* o, void*) {
  progdefaults.UseLastMacro = o->value();
update_main_title();
progdefaults.changed = true;
}

Fl_Check_Button *btnDisplayMacroFilename=(Fl_Check_Button *)0;

static void cb_btnDisplayMacroFilename(Fl_Check_Button* o, void*) {
  progdefaults.DisplayMacroFilename = o->value();
progdefaults.changed = true;
}

Fl_Group *tabContest=(Fl_Group *)0;

Fl_Box *lblSend=(Fl_Box *)0;

Fl_Input2 *inpSend1=(Fl_Input2 *)0;

static void cb_inpSend1(Fl_Input2* o, void*) {
  progdefaults.myXchg=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btn599=(Fl_Check_Button *)0;

static void cb_btn599(Fl_Check_Button* o, void*) {
  progdefaults.fixed599 = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCutNbrs=(Fl_Check_Button *)0;

static void cb_btnCutNbrs(Fl_Check_Button* o, void*) {
  progdefaults.cutnbrs=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseLeadingZeros=(Fl_Check_Button *)0;

static void cb_btnUseLeadingZeros(Fl_Check_Button* o, void*) {
  progdefaults.UseLeadingZeros = o->value();
progdefaults.changed = true;
}

Fl_Value_Input2 *nbrContestStart=(Fl_Value_Input2 *)0;

static void cb_nbrContestStart(Fl_Value_Input2* o, void*) {
  progdefaults.ContestStart = (int)o->value();
progdefaults.changed = true;
}

Fl_Value_Input2 *nbrContestDigits=(Fl_Value_Input2 *)0;

static void cb_nbrContestDigits(Fl_Value_Input2* o, void*) {
  progdefaults.ContestDigits = (int)o->value();
progdefaults.changed = true;
}

Fl_Button *btnResetSerNbr=(Fl_Button *)0;

static void cb_btnResetSerNbr(Fl_Button*, void*) {
  cb_ResetSerNbr();
}

Fl_Light_Button *btnDupCheckOn=(Fl_Light_Button *)0;

static void cb_btnDupCheckOn(Fl_Light_Button* o, void*) {
  progdefaults.EnableDupCheck = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDupBand=(Fl_Check_Button *)0;

static void cb_btnDupBand(Fl_Check_Button* o, void*) {
  progdefaults.dupband = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDupMode=(Fl_Check_Button *)0;

static void cb_btnDupMode(Fl_Check_Button* o, void*) {
  progdefaults.dupmode = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDupState=(Fl_Check_Button *)0;

static void cb_btnDupState(Fl_Check_Button* o, void*) {
  progdefaults.dupstate = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDupXchg1=(Fl_Check_Button *)0;

static void cb_btnDupXchg1(Fl_Check_Button* o, void*) {
  progdefaults.dupxchg1 = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDupTimeSpan=(Fl_Check_Button *)0;

static void cb_btnDupTimeSpan(Fl_Check_Button* o, void*) {
  progdefaults.duptimespan=(int)o->value();
progdefaults.changed = true;
}

Fl_Value_Input2 *nbrTimeSpan=(Fl_Value_Input2 *)0;

static void cb_nbrTimeSpan(Fl_Value_Input2* o, void*) {
  progdefaults.timespan = (int)o->value();
progdefaults.changed = true;
}

Fl_Button *btnDupColor=(Fl_Button *)0;

static void cb_btnDupColor(Fl_Button* o, void*) {
  fl_color_chooser("Dup Check", 
  progdefaults.dup_color.R, 
  progdefaults.dup_color.G, 
  progdefaults.dup_color.B);
o->color(
  fl_rgb_color(
    progdefaults.dup_color.R,
    progdefaults.dup_color.G,
    progdefaults.dup_color.B));
o->redraw();
progdefaults.changed = true;
}

Fl_Group *tabWF_UI=(Fl_Group *)0;

Fl_Check_Button *btnWF_UIrev=(Fl_Check_Button *)0;

static void cb_btnWF_UIrev(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIrev = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIx1=(Fl_Check_Button *)0;

static void cb_btnWF_UIx1(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIx1 = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfcarrier=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfcarrier(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfcarrier = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfshift=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfshift(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfshift = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfreflevel=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfreflevel(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfreflevel = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfdrop=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfdrop(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfdrop = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfampspan=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfampspan(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfampspan = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfstore=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfstore(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfstore = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIwfmode=(Fl_Check_Button *)0;

static void cb_btnWF_UIwfmode(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIwfmode = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIqsy=(Fl_Check_Button *)0;

static void cb_btnWF_UIqsy(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIqsy = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Check_Button *btnWF_UIxmtlock=(Fl_Check_Button *)0;

static void cb_btnWF_UIxmtlock(Fl_Check_Button* o, void*) {
  progdefaults.WF_UIxmtlock = o->value();
progdefaults.changed = true;
WF_UI();
}

Fl_Button *btn_wf_enable_all=(Fl_Button *)0;

static void cb_btn_wf_enable_all(Fl_Button*, void*) {
  btnWF_UIrev->value(progdefaults.WF_UIrev = 1);
btnWF_UIwfcarrier->value(progdefaults.WF_UIwfcarrier = 1);
btnWF_UIwfreflevel->value(progdefaults.WF_UIwfreflevel = 1);
btnWF_UIwfampspan->value(progdefaults.WF_UIwfampspan = 1);
btnWF_UIwfmode->value(progdefaults.WF_UIwfmode = 1);

btnWF_UIx1->value(progdefaults.WF_UIx1 = 1);
btnWF_UIwfshift->value(progdefaults.WF_UIwfshift = 1);
btnWF_UIwfdrop->value(progdefaults.WF_UIwfdrop = 1);
btnWF_UIwfstore->value(progdefaults.WF_UIwfstore = 1);
btnWF_UIqsy->value(progdefaults.WF_UIqsy = 1);
btnWF_UIxmtlock->value(progdefaults.WF_UIxmtlock = 1);

progdefaults.changed = true;
WF_UI();
}

Fl_Button *btn_wf_disable_all=(Fl_Button *)0;

static void cb_btn_wf_disable_all(Fl_Button*, void*) {
  btnWF_UIrev->value(progdefaults.WF_UIrev = 0);
btnWF_UIwfcarrier->value(progdefaults.WF_UIwfcarrier = 0);
btnWF_UIwfreflevel->value(progdefaults.WF_UIwfreflevel = 0);
btnWF_UIwfampspan->value(progdefaults.WF_UIwfampspan = 0);
btnWF_UIwfmode->value(progdefaults.WF_UIwfmode = 0);

btnWF_UIx1->value(progdefaults.WF_UIx1 = 0);
btnWF_UIwfshift->value(progdefaults.WF_UIwfshift = 0);
btnWF_UIwfdrop->value(progdefaults.WF_UIwfdrop = 0);
btnWF_UIwfstore->value(progdefaults.WF_UIwfstore = 0);
btnWF_UIqsy->value(progdefaults.WF_UIqsy = 0);
btnWF_UIxmtlock->value(progdefaults.WF_UIxmtlock = 0);

progdefaults.changed = true;
WF_UI();
}

Fl_Group *tabRxText=(Fl_Group *)0;

Fl_Check_Button *btn_rx_lowercase=(Fl_Check_Button *)0;

static void cb_btn_rx_lowercase(Fl_Check_Button* o, void*) {
  progdefaults.rx_lowercase = o->value();
progdefaults.changed = true;
}

Fl_Group *tabLogServer=(Fl_Group *)0;

Fl_Input *xmllogServerAddress=(Fl_Input *)0;

static void cb_xmllogServerAddress(Fl_Input* o, void*) {
  progdefaults.xmllog_address = o->value();
}

Fl_Input *xmllogServerPort=(Fl_Input *)0;

static void cb_xmllogServerPort(Fl_Input* o, void*) {
  progdefaults.xmllog_port = o->value();
}

Fl_Button *btn_reconnect_log_server=(Fl_Button *)0;

static void cb_btn_reconnect_log_server(Fl_Button*, void*) {
  progdefaults.xml_logbook = true;
connect_to_log_server();
}

Fl_Group *tabWaterfall=(Fl_Group *)0;

Fl_Tabs *tabsWaterfall=(Fl_Tabs *)0;

colorbox *WF_Palette=(colorbox *)0;

static void cb_WF_Palette(colorbox*, void*) {
  progdefaults.changed = true;
}

static void cb_btnColor(Fl_Button*, void*) {
  selectColor(0);
progdefaults.changed = true;
}

static void cb_btnColor1(Fl_Button*, void*) {
  selectColor(1);
progdefaults.changed = true;
}

static void cb_btnColor2(Fl_Button*, void*) {
  selectColor(2);
progdefaults.changed = true;
}

static void cb_btnColor3(Fl_Button*, void*) {
  selectColor(3);
progdefaults.changed = true;
}

static void cb_btnColor4(Fl_Button*, void*) {
  selectColor(4);
progdefaults.changed = true;
}

static void cb_btnColor5(Fl_Button*, void*) {
  selectColor(5);
progdefaults.changed = true;
}

static void cb_btnColor6(Fl_Button*, void*) {
  selectColor(6);
progdefaults.changed = true;
}

static void cb_btnColor7(Fl_Button*, void*) {
  selectColor(7);
progdefaults.changed = true;
}

Fl_Button *btnColor[9]={(Fl_Button *)0};

static void cb_btnColor8(Fl_Button*, void*) {
  selectColor(8);
progdefaults.changed = true;
}

Fl_Button *btnLoadPalette=(Fl_Button *)0;

static void cb_btnLoadPalette(Fl_Button*, void*) {
  loadPalette();
progdefaults.changed = true;
}

Fl_Button *btnSavePalette=(Fl_Button *)0;

static void cb_btnSavePalette(Fl_Button*, void*) {
  savePalette();
}

Fl_Check_Button *btnUseCursorLines=(Fl_Check_Button *)0;

static void cb_btnUseCursorLines(Fl_Check_Button* o, void*) {
  progdefaults.UseCursorLines = o->value();
if (o->value())
    btnCursorBWcolor->activate();
else
    btnCursorBWcolor->deactivate();
progdefaults.changed = true;
}

Fl_Button *btnCursorBWcolor=(Fl_Button *)0;

static void cb_btnCursorBWcolor(Fl_Button* o, void*) {
  if (fl_color_chooser("Cursor BW Lines",
  progdefaults.cursorLineRGBI.R, 
  progdefaults.cursorLineRGBI.G, 
  progdefaults.cursorLineRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.cursorLineRGBI.R,progdefaults.cursorLineRGBI.G,progdefaults.cursorLineRGBI.B));
o->redraw();
progdefaults.changed = true;
};
}

Fl_Check_Button *btnUseCursorCenterLine=(Fl_Check_Button *)0;

static void cb_btnUseCursorCenterLine(Fl_Check_Button* o, void*) {
  progdefaults.UseCursorCenterLine = o->value();
progdefaults.changed = true;
}

Fl_Button *btnCursorCenterLineColor=(Fl_Button *)0;

static void cb_btnCursorCenterLineColor(Fl_Button* o, void*) {
  if (fl_color_chooser("Cursor Center Line",
  progdefaults.cursorCenterRGBI.R, 
  progdefaults.cursorCenterRGBI.G, 
  progdefaults.cursorCenterRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.cursorCenterRGBI.R,progdefaults.cursorCenterRGBI.G,progdefaults.cursorCenterRGBI.B));
o->redraw();
progdefaults.changed = true;
};
}

Fl_Check_Button *btnUseBWTracks=(Fl_Check_Button *)0;

static void cb_btnUseBWTracks(Fl_Check_Button* o, void*) {
  progdefaults.UseBWTracks = o->value();
progdefaults.changed = true;
}

Fl_Button *btnBwTracksColor=(Fl_Button *)0;

static void cb_btnBwTracksColor(Fl_Button* o, void*) {
  if (fl_color_chooser("Track Lines",
  progdefaults.bwTrackRGBI.R, 
  progdefaults.bwTrackRGBI.G, 
  progdefaults.bwTrackRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.bwTrackRGBI.R,progdefaults.bwTrackRGBI.G,progdefaults.bwTrackRGBI.B));
o->redraw();
wf->redraw_marker();
progdefaults.changed = true;
};
}

Fl_Check_Button *btnUseWideTracks=(Fl_Check_Button *)0;

static void cb_btnUseWideTracks(Fl_Check_Button* o, void*) {
  progdefaults.UseWideTracks = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseWideCenter=(Fl_Check_Button *)0;

static void cb_btnUseWideCenter(Fl_Check_Button* o, void*) {
  progdefaults.UseWideCenter = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseWideCursor=(Fl_Check_Button *)0;

static void cb_btnUseWideCursor(Fl_Check_Button* o, void*) {
  progdefaults.UseWideCursor = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkShowAudioScale=(Fl_Check_Button *)0;

static void cb_chkShowAudioScale(Fl_Check_Button* o, void*) {
  progdefaults.wf_audioscale = o->value();
progdefaults.changed = true;
}

Fl_Button *btnWaterfallFont=(Fl_Button *)0;

static void cb_btnWaterfallFont(Fl_Button*, void*) {
  font_browser->fontNumber(progdefaults.WaterfallFontnbr);
font_browser->fontSize(progdefaults.WaterfallFontsize);
font_browser->fontColor(FL_FOREGROUND_COLOR);
font_browser->fontFilter(Font_Browser::ALL_TYPES);
font_browser->callback((Fl_Callback*)cbWaterfallFontBrowser);
font_browser->show();
}

Fl_Check_Button *btnViewXmtSignal=(Fl_Check_Button *)0;

static void cb_btnViewXmtSignal(Fl_Check_Button* o, void*) {
  progdefaults.viewXmtSignal=o->value();
progdefaults.changed = true;
}

Fl_Value_Slider2 *valTxMonitorLevel=(Fl_Value_Slider2 *)0;

static void cb_valTxMonitorLevel(Fl_Value_Slider2* o, void*) {
  progdefaults.TxMonitorLevel = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntLowFreqCutoff=(Fl_Counter2 *)0;

static void cb_cntLowFreqCutoff(Fl_Counter2* o, void*) {
  progdefaults.LowFreqCutoff=(int)(o->value());
progdefaults.changed = true;
setwfrange();
}

Fl_Counter2 *valLatency=(Fl_Counter2 *)0;

static void cb_valLatency(Fl_Counter2* o, void*) {
  progdefaults.latency = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWFaveraging=(Fl_Check_Button *)0;

static void cb_btnWFaveraging(Fl_Check_Button* o, void*) {
  progdefaults.WFaveraging = o->value();
progdefaults.changed = true;
}

Fl_Choice *mnuFFTPrefilter=(Fl_Choice *)0;

static void cb_mnuFFTPrefilter(Fl_Choice* o, void*) {
  progdefaults.wfPreFilter = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntrWfwidth=(Fl_Counter2 *)0;

static void cb_cntrWfwidth(Fl_Counter2* o, void*) {
  progdefaults.HighFreqCutoff = (int)o->value();
progdefaults.changed = true;
setwfrange();
}

Fl_Counter2 *cntrWfheight=(Fl_Counter2 *)0;

static void cb_cntrWfheight(Fl_Counter2* o, void*) {
  progdefaults.wfheight = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWaterfallHistoryDefault=(Fl_Check_Button *)0;

static void cb_btnWaterfallHistoryDefault(Fl_Check_Button* o, void*) {
  progdefaults.WaterfallHistoryDefault = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWaterfallQSY=(Fl_Check_Button *)0;

static void cb_btnWaterfallQSY(Fl_Check_Button* o, void*) {
  progdefaults.WaterfallQSY = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWaterfallClickInsert=(Fl_Check_Button *)0;

static void cb_btnWaterfallClickInsert(Fl_Check_Button* o, void*) {
  progdefaults.WaterfallClickInsert = o->value();
if (progdefaults.WaterfallClickInsert)
    inpWaterfallClickText->activate();
else
    inpWaterfallClickText->deactivate();
progdefaults.changed = true;
}

Fl_Input2 *inpWaterfallClickText=(Fl_Input2 *)0;

static void cb_inpWaterfallClickText(Fl_Input2* o, void*) {
  progdefaults.WaterfallClickText = o->value();
progdefaults.changed = true;
}

Fl_Choice *mnuWaterfallWheelAction=(Fl_Choice *)0;

static void cb_mnuWaterfallWheelAction(Fl_Choice* o, void*) {
  progdefaults.WaterfallWheelAction = o->value();
progdefaults.changed = true;
}

Fl_Group *tabModems=(Fl_Group *)0;

Fl_Tabs *tabsModems=(Fl_Tabs *)0;

Fl_Group *tabCW=(Fl_Group *)0;

Fl_Tabs *tabsCW=(Fl_Tabs *)0;

Fl_Value_Slider2 *sldrCWbandwidth=(Fl_Value_Slider2 *)0;

static void cb_sldrCWbandwidth(Fl_Value_Slider2* o, void*) {
  progdefaults.CWbandwidth = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCWrcvTrack=(Fl_Check_Button *)0;

static void cb_btnCWrcvTrack(Fl_Check_Button* o, void*) {
  progdefaults.CWtrack = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntCWrange=(Fl_Counter2 *)0;

static void cb_cntCWrange(Fl_Counter2* o, void*) {
  progdefaults.CWrange = (int)o->value();
progdefaults.changed = true;
}

Fl_Value_Output *valCWrcvWPM=(Fl_Value_Output *)0;

static void cb_valCWrcvWPM(Fl_Value_Output*, void*) {
  progdefaults.changed = true;
}

Fl_Progress *prgsCWrcvWPM=(Fl_Progress *)0;

Fl_Value_Slider2 *sldrCWxmtWPM=(Fl_Value_Slider2 *)0;

static void cb_sldrCWxmtWPM(Fl_Value_Slider2* o, void*) {
  progdefaults.CWspeed = (int)o->value();
cntCW_WPM->value(progdefaults.CWspeed);
sldrCWfarnsworth->maximum(progdefaults.CWspeed);
if (sldrCWfarnsworth->value() > progdefaults.CWspeed)
sldrCWfarnsworth->value(progdefaults.CWspeed);
progdefaults.changed = true;
sync_cw_parameters();
}

Fl_Counter2 *cntCWdefWPM=(Fl_Counter2 *)0;

static void cb_cntCWdefWPM(Fl_Counter2* o, void*) {
  progdefaults.defCWspeed = (int)o->value();
progdefaults.changed = true;
}

Fl_Counter *cntCWlowerlimit=(Fl_Counter *)0;

static void cb_cntCWlowerlimit(Fl_Counter* o, void*) {
  progdefaults.CWlowerlimit = (int)o->value();
progdefaults.changed = true;
sldrCWxmtWPM->minimum(progdefaults.CWlowerlimit);
sldrCWxmtWPM->value(progdefaults.CWspeed);
sldrCWxmtWPM->redraw();
cntCWupperlimit->minimum(progdefaults.CWlowerlimit+20);
cntCW_WPM->minimum(progdefaults.CWlowerlimit);
}

Fl_Counter *cntCWupperlimit=(Fl_Counter *)0;

static void cb_cntCWupperlimit(Fl_Counter* o, void*) {
  progdefaults.CWupperlimit = (int)o->value();
progdefaults.changed = true;
sldrCWxmtWPM->maximum(progdefaults.CWupperlimit);
sldrCWxmtWPM->value(progdefaults.CWspeed);
sldrCWxmtWPM->redraw();
cntCWlowerlimit->maximum(progdefaults.CWupperlimit-20);
cntCW_WPM->maximum(progdefaults.CWupperlimit);
}

Fl_Value_Slider2 *sldrCWfarnsworth=(Fl_Value_Slider2 *)0;

static void cb_sldrCWfarnsworth(Fl_Value_Slider2* o, void*) {
  progdefaults.CWfarnsworth = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCWusefarnsworth=(Fl_Check_Button *)0;

static void cb_btnCWusefarnsworth(Fl_Check_Button* o, void*) {
  progdefaults.CWusefarnsworth=o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntCWweight=(Fl_Counter2 *)0;

static void cb_cntCWweight(Fl_Counter2* o, void*) {
  progdefaults.CWweight=(int)o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntCWdash2dot=(Fl_Counter2 *)0;

static void cb_cntCWdash2dot(Fl_Counter2* o, void*) {
  progdefaults.CWdash2dot=o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntCWrisetime=(Fl_Counter2 *)0;

static void cb_cntCWrisetime(Fl_Counter2* o, void*) {
  progdefaults.CWrisetime=o->value();
progdefaults.changed = true;
}

Fl_Choice *mnuQSKshape=(Fl_Choice *)0;

static void cb_mnuQSKshape(Fl_Choice* o, void*) {
  progdefaults.QSKshape = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCWnarrow=(Fl_Check_Button *)0;

static void cb_btnCWnarrow(Fl_Check_Button* o, void*) {
  progdefaults.CWnarrow = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnQSK=(Fl_Check_Button *)0;

static void cb_btnQSK(Fl_Check_Button* o, void*) {
  if (o->value() && !sound_check_right_channel()) {
  o->value(0);
  return;
}
progdefaults.QSK = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntPreTiming=(Fl_Counter2 *)0;

static void cb_cntPreTiming(Fl_Counter2* o, void*) {
  progdefaults.CWpre=o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntPostTiming=(Fl_Counter2 *)0;

static void cb_cntPostTiming(Fl_Counter2* o, void*) {
  progdefaults.CWpost=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnQSKadjust=(Fl_Check_Button *)0;

static void cb_btnQSKadjust(Fl_Check_Button* o, void*) {
  progdefaults.QSKadjust = o->value();
}

Fl_Choice *mnuTestChar=(Fl_Choice *)0;

static void cb_mnuTestChar(Fl_Choice* o, void*) {
  progdefaults.TestChar = o->value();
}

Fl_Check_Button *btnCW_use_paren=(Fl_Check_Button *)0;

static void cb_btnCW_use_paren(Fl_Check_Button* o, void*) {
  progdefaults.CW_use_paren=o->value();
progdefaults.changed = true;
}

static void cb_mnu_prosign(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[0] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign1(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c); 
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[1] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign2(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[2] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign3(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[3] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign4(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[4] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign5(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[5] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign6(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[6] = ps[c];
progdefaults.changed = true;
}

static void cb_mnu_prosign7(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[7] = ps[c];
progdefaults.changed = true;
}

Fl_Choice *mnu_prosign[9]={(Fl_Choice *)0};

static void cb_mnu_prosign8(Fl_Choice* o, void*) {
  int c = o->value();
for (int i = 0; i < 9; i++)
  if (mnu_prosign[i]->value() == c) {
    mnu_prosign[i]->value(11);
    progdefaults.CW_prosigns[i] = ' ';
  }
o->value(c);
char ps[] = "~%&+={}<>[] ";
progdefaults.CW_prosigns[8] = ps[c];
progdefaults.changed = true;
}

Fl_Group *tabDomEX=(Fl_Group *)0;

Fl_Input2 *txtSecondary=(Fl_Input2 *)0;

static void cb_txtSecondary(Fl_Input2* o, void*) {
  progdefaults.secText = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *valDominoEX_FILTER=(Fl_Check_Button *)0;

static void cb_valDominoEX_FILTER(Fl_Check_Button* o, void*) {
  progdefaults.DOMINOEX_FILTER = o->value();
resetDOMEX();
progdefaults.changed = true;
}

Fl_Counter2 *valDominoEX_BW=(Fl_Counter2 *)0;

static void cb_valDominoEX_BW(Fl_Counter2* o, void*) {
  progdefaults.DOMINOEX_BW = o->value();
resetDOMEX();
progdefaults.changed = true;
}

Fl_Check_Button *chkDominoEX_FEC=(Fl_Check_Button *)0;

static void cb_chkDominoEX_FEC(Fl_Check_Button* o, void*) {
  progdefaults.DOMINOEX_FEC = o->value();
progdefaults.changed = true;
}

Fl_Value_Slider2 *valDomCWI=(Fl_Value_Slider2 *)0;

static void cb_valDomCWI(Fl_Value_Slider2* o, void*) {
  progdefaults.DomCWI = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *valDominoEX_PATHS=(Fl_Counter2 *)0;

static void cb_valDominoEX_PATHS(Fl_Counter2* o, void*) {
  progdefaults.DOMINOEX_PATHS = (int)o->value();
progdefaults.changed = true;
}

Fl_Group *tabFeld=(Fl_Group *)0;

Fl_Choice *selHellFont=(Fl_Choice *)0;

static void cb_selHellFont(Fl_Choice* o, void*) {
  progdefaults.feldfontnbr=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnBlackboard=(Fl_Check_Button *)0;

static void cb_btnBlackboard(Fl_Check_Button* o, void*) {
  progdefaults.HellBlackboard=o->value();
progdefaults.changed = true;
}

Fl_Spinner2 *valHellXmtWidth=(Fl_Spinner2 *)0;

static void cb_valHellXmtWidth(Fl_Spinner2* o, void*) {
  progdefaults.HellXmtWidth=(int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnHellRcvWidth=(Fl_Check_Button *)0;

static void cb_btnHellRcvWidth(Fl_Check_Button* o, void*) {
  progdefaults.HellRcvWidth=o->value();
progdefaults.changed = true;
}

Fl_Choice *mnuHellPulse=(Fl_Choice *)0;

static void cb_mnuHellPulse(Fl_Choice* o, void*) {
  progdefaults.HellPulseFast = o->value();
progdefaults.changed = true;
}

Fl_Value_Slider2 *sldrHellBW=(Fl_Value_Slider2 *)0;

static void cb_sldrHellBW(Fl_Value_Slider2*, void*) {
  progdefaults.HELL_BW = sldrHellBW->value();
}

Fl_Check_Button *btnFeldHellIdle=(Fl_Check_Button *)0;

static void cb_btnFeldHellIdle(Fl_Check_Button* o, void*) {
  progdefaults.HellXmtIdle=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnHellXmtWidth=(Fl_Check_Button *)0;

static void cb_btnHellXmtWidth(Fl_Check_Button* o, void*) {
  progdefaults.HellXmtWidth=o->value();
progdefaults.changed = true;
}

Fl_Group *tabMT63=(Fl_Group *)0;

Fl_Check_Button *btnmt63_interleave=(Fl_Check_Button *)0;

static void cb_btnmt63_interleave(Fl_Check_Button* o, void*) {
  if (o->value() == 1)
progdefaults.mt63_interleave = 64;
else
progdefaults.mt63_interleave = 32;
progdefaults.changed = true;
}

Fl_Check_Button *btnMT63_8bit=(Fl_Check_Button *)0;

static void cb_btnMT63_8bit(Fl_Check_Button* o, void*) {
  progdefaults.mt63_8bit = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnMT63_rx_integration=(Fl_Check_Button *)0;

static void cb_btnMT63_rx_integration(Fl_Check_Button* o, void*) {
  progdefaults.mt63_rx_integration = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnMT63_usetones=(Fl_Check_Button *)0;

static void cb_btnMT63_usetones(Fl_Check_Button* o, void*) {
  progdefaults.mt63_usetones = o->value();
if (!o->value()) {
    btnMT63_upper_lower->value(0);
    btnMT63_upper_lower->do_callback();
    btnMT63_upper_lower->deactivate();
}
else
    btnMT63_upper_lower->activate();
progdefaults.changed = true;
}

Fl_Check_Button *btnMT63_upper_lower=(Fl_Check_Button *)0;

static void cb_btnMT63_upper_lower(Fl_Check_Button* o, void*) {
  progdefaults.mt63_twotones = o->value();
progdefaults.changed = true;
}

Fl_Spinner2 *MT63_tone_duration=(Fl_Spinner2 *)0;

static void cb_MT63_tone_duration(Fl_Spinner2* o, void*) {
  progdefaults.mt63_tone_duration=(int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnMT63_at500=(Fl_Check_Button *)0;

static void cb_btnMT63_at500(Fl_Check_Button* o, void*) {
  progdefaults.mt63_at500 = !o->value();
progdefaults.changed = true;
}

Fl_Group *tabOlivia=(Fl_Group *)0;

Fl_Choice *mnuOlivia_Bandwidth=(Fl_Choice *)0;

static void cb_mnuOlivia_Bandwidth(Fl_Choice* o, void*) {
  progdefaults.oliviabw = o->value();
set_olivia_default_integ();
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Choice *mnuOlivia_Tones=(Fl_Choice *)0;

static void cb_mnuOlivia_Tones(Fl_Choice* o, void*) {
  progdefaults.oliviatones = o->value();
set_olivia_default_integ();
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Counter2 *cntOlivia_smargin=(Fl_Counter2 *)0;

static void cb_cntOlivia_smargin(Fl_Counter2* o, void*) {
  progdefaults.oliviasmargin = (int)(o->value());
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Counter2 *cntOlivia_sinteg=(Fl_Counter2 *)0;

static void cb_cntOlivia_sinteg(Fl_Counter2* o, void*) {
  progdefaults.oliviasinteg = (int)(o->value());
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Check_Button *btnOlivia_8bit=(Fl_Check_Button *)0;

static void cb_btnOlivia_8bit(Fl_Check_Button* o, void*) {
  progdefaults.olivia8bit = o->value();
progdefaults.changed = true;
}

Fl_Group *tabContestia=(Fl_Group *)0;

Fl_Choice *mnuContestia_Bandwidth=(Fl_Choice *)0;

static void cb_mnuContestia_Bandwidth(Fl_Choice* o, void*) {
  progdefaults.contestiabw = o->value();
set_contestia_default_integ();
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Choice *mnuContestia_Tones=(Fl_Choice *)0;

static void cb_mnuContestia_Tones(Fl_Choice* o, void*) {
  progdefaults.contestiatones = o->value();
set_contestia_default_integ();
resetCONTESTIA();
progdefaults.changed = true;
}

Fl_Counter2 *cntContestia_smargin=(Fl_Counter2 *)0;

static void cb_cntContestia_smargin(Fl_Counter2* o, void*) {
  progdefaults.contestiasmargin = (int)(o->value());
resetCONTESTIA();
progdefaults.changed = true;
}

Fl_Counter2 *cntContestia_sinteg=(Fl_Counter2 *)0;

static void cb_cntContestia_sinteg(Fl_Counter2* o, void*) {
  progdefaults.contestiasinteg = (int)(o->value());
resetCONTESTIA();
progdefaults.changed = true;
}

Fl_Check_Button *btnContestia_8bit=(Fl_Check_Button *)0;

static void cb_btnContestia_8bit(Fl_Check_Button* o, void*) {
  progdefaults.contestia8bit = o->value();
progdefaults.changed = true;
}

Fl_Group *tabPSK=(Fl_Group *)0;

Fl_Tabs *tabsPSK=(Fl_Tabs *)0;

Fl_Counter2 *cntSearchRange=(Fl_Counter2 *)0;

static void cb_cntSearchRange(Fl_Counter2* o, void*) {
  progdefaults.SearchRange = (int)o->value();
wf->redraw_marker();
progdefaults.changed = true;
}

Fl_Counter2 *cntACQsn=(Fl_Counter2 *)0;

static void cb_cntACQsn(Fl_Counter2* o, void*) {
  progdefaults.ACQsn = o->value();
progdefaults.changed = true;
}

Fl_Choice *mnuPSKStatusTimeout=(Fl_Choice *)0;

static void cb_mnuPSKStatusTimeout(Fl_Choice* o, void*) {
  progdefaults.StatusDim = o->value();
progdefaults.changed = true;
}

static void cb_seconds(Fl_Counter2* o, void*) {
  progdefaults.StatusTimeout = (int)(o->value());
progdefaults.changed = true;
}

Fl_Check_Button *btnEnablePSKbrowsing=(Fl_Check_Button *)0;

static void cb_btnEnablePSKbrowsing(Fl_Check_Button* o, void*) {
  progdefaults.pskbrowser_on = o->value();
progdefaults.changed = true;
}

Fl_Group *tabRTTY=(Fl_Group *)0;

Fl_Choice *selShift=(Fl_Choice *)0;

static void cb_selShift(Fl_Choice* o, void*) {
  progdefaults.rtty_shift = o->value();
if (progdefaults.rtty_shift == o->size() - 2) {
    progdefaults.rtty_shift = -1;
    selCustomShift->activate();
}
else
    selCustomShift->deactivate();
resetRTTY();
progdefaults.changed = true;
}

Fl_Choice *selBaud=(Fl_Choice *)0;

static void cb_selBaud(Fl_Choice* o, void*) {
  progdefaults.rtty_baud = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Choice *selBits=(Fl_Choice *)0;

static void cb_selBits(Fl_Choice* o, void*) {
  progdefaults.rtty_bits = o->value();
selParity->do_callback();
}

Fl_Choice *selParity=(Fl_Choice *)0;

static void cb_selParity(Fl_Choice* o, void*) {
  if (progdefaults.rtty_bits == 0)
  o->value(progdefaults.rtty_parity = RTTY_PARITY_NONE);
else
  progdefaults.rtty_parity = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Choice *selStopBits=(Fl_Choice *)0;

static void cb_selStopBits(Fl_Choice* o, void*) {
  progdefaults.rtty_stop = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Check_Button *btnAUTOCRLF=(Fl_Check_Button *)0;

static void cb_btnAUTOCRLF(Fl_Check_Button* o, void*) {
  progdefaults.rtty_autocrlf = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCRCRLF=(Fl_Check_Button *)0;

static void cb_btnCRCRLF(Fl_Check_Button* o, void*) {
  progdefaults.rtty_crcrlf = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntrAUTOCRLF=(Fl_Counter2 *)0;

static void cb_cntrAUTOCRLF(Fl_Counter2* o, void*) {
  progdefaults.rtty_autocount = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkUOSrx=(Fl_Check_Button *)0;

static void cb_chkUOSrx(Fl_Check_Button* o, void*) {
  progdefaults.UOSrx=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkUOStx=(Fl_Check_Button *)0;

static void cb_chkUOStx(Fl_Check_Button* o, void*) {
  progdefaults.UOStx=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chk_useMARKfreq=(Fl_Check_Button *)0;

static void cb_chk_useMARKfreq(Fl_Check_Button* o, void*) {
  progdefaults.useMARKfreq=o->value();
progdefaults.changed = true;
}

Fl_Button *btnRTTY_mark_color=(Fl_Button *)0;

static void cb_btnRTTY_mark_color(Fl_Button* o, void*) {
  if (fl_color_chooser("MARK freq track",
  progdefaults.rttymarkRGBI.R, 
  progdefaults.rttymarkRGBI.G, 
  progdefaults.rttymarkRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.rttymarkRGBI.R,progdefaults.rttymarkRGBI.G,progdefaults.rttymarkRGBI.B));
o->redraw();
wf->redraw_marker();
progdefaults.changed = true;
};
}

Fl_Check_Button *btnPreferXhairScope=(Fl_Check_Button *)0;

static void cb_btnPreferXhairScope(Fl_Check_Button* o, void*) {
  progdefaults.PreferXhairScope=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkPseudoFSK=(Fl_Check_Button *)0;

static void cb_chkPseudoFSK(Fl_Check_Button* o, void*) {
  if (o->value() && !sound_check_right_channel()) {
  o->value(0);
  return;
}
progdefaults.PseudoFSK = o->value();
progdefaults.changed = true;
}

Fl_Choice *mnuRTTYAFCSpeed=(Fl_Choice *)0;

static void cb_mnuRTTYAFCSpeed(Fl_Choice* o, void*) {
  progdefaults.rtty_afcspeed = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkXagc=(Fl_Check_Button *)0;

static void cb_chkXagc(Fl_Check_Button* o, void*) {
  progdefaults.Xagc=o->value();
progdefaults.changed = true;
}

Fl_Value_Slider2 *sldrRTTYbandwidth=(Fl_Value_Slider2 *)0;

static void cb_sldrRTTYbandwidth(Fl_Value_Slider2* o, void*) {
  progdefaults.RTTY_BW = o->value();
}

Fl_Counter2 *selCustomShift=(Fl_Counter2 *)0;

static void cb_selCustomShift(Fl_Counter2* o, void*) {
  progdefaults.rtty_custom_shift = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Group *tabTHOR=(Fl_Group *)0;

Fl_Input2 *txtTHORSecondary=(Fl_Input2 *)0;

static void cb_txtTHORSecondary(Fl_Input2* o, void*) {
  progdefaults.THORsecText = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *valTHOR_FILTER=(Fl_Check_Button *)0;

static void cb_valTHOR_FILTER(Fl_Check_Button* o, void*) {
  progdefaults.THOR_FILTER = o->value();
resetTHOR();
progdefaults.changed = true;
}

Fl_Counter2 *valTHOR_BW=(Fl_Counter2 *)0;

static void cb_valTHOR_BW(Fl_Counter2* o, void*) {
  progdefaults.THOR_BW = o->value();
resetTHOR();
progdefaults.changed = true;
}

Fl_Value_Slider2 *valThorCWI=(Fl_Value_Slider2 *)0;

static void cb_valThorCWI(Fl_Value_Slider2* o, void*) {
  progdefaults.ThorCWI = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *valTHOR_PATHS=(Fl_Counter2 *)0;

static void cb_valTHOR_PATHS(Fl_Counter2* o, void*) {
  progdefaults.THOR_PATHS = (int)o->value();
progdefaults.changed = true;
}

Fl_Group *tabRig=(Fl_Group *)0;

Fl_Tabs *tabsRig=(Fl_Tabs *)0;

Fl_Group *grpHWPTT=(Fl_Group *)0;

Fl_Input_Choice *inpTTYdev=(Fl_Input_Choice *)0;

static void cb_inpTTYdev(Fl_Input_Choice*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnRTSptt=(Fl_Round_Button *)0;

static void cb_btnRTSptt(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnRTSplusV=(Fl_Round_Button *)0;

static void cb_btnRTSplusV(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnDTRptt=(Fl_Round_Button *)0;

static void cb_btnDTRptt(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnDTRplusV=(Fl_Round_Button *)0;

static void cb_btnDTRplusV(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Button *btnInitHWPTT=(Fl_Button *)0;

static void cb_btnInitHWPTT(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Round_Button *btnTTYptt=(Fl_Round_Button *)0;

static void cb_btnTTYptt(Fl_Round_Button* o, void*) {
  btnUsePPortPTT->value(false);
btnUseUHrouterPTT->value(false);

progdefaults.TTYptt = o->value();
progdefaults.UsePPortPTT = false;
progdefaults.UseUHrouterPTT = false;
btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnUsePPortPTT=(Fl_Round_Button *)0;

static void cb_btnUsePPortPTT(Fl_Round_Button* o, void*) {
  btnTTYptt->value(false);
btnUseUHrouterPTT->value(false);

progdefaults.TTYptt = false;
progdefaults.UsePPortPTT = o->value();
progdefaults.UseUHrouterPTT = false;
btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnUseUHrouterPTT=(Fl_Round_Button *)0;

static void cb_btnUseUHrouterPTT(Fl_Round_Button* o, void*) {
  btnTTYptt->value(false);
btnUsePPortPTT->value(false);

progdefaults.TTYptt = false;
progdefaults.UsePPortPTT = false;
progdefaults.UseUHrouterPTT = o->value();
btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *btnPTTrightchannel=(Fl_Check_Button *)0;

static void cb_btnPTTrightchannel(Fl_Check_Button* o, void*) {
  if (o->value() && !sound_check_right_channel()) {
  o->value(0);
  return;
}
progdefaults.PTTrightchannel = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkUSERIGCAT=(Fl_Check_Button *)0;

static void cb_chkUSERIGCAT(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
  chkUSEHAMLIB->value(0);
  chkUSEMEMMAP->value(0);
  chkUSEXMLRPC->value(0);
  progdefaults.chkUSEMEMMAPis = false;
  progdefaults.chkUSEHAMLIBis = false;
  progdefaults.chkUSERIGCATis = true;
  progdefaults.chkUSEXMLRPCis = false;
  } else {
  progdefaults.chkUSERIGCATis = false;
  }
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
}

Fl_Group *grpRigCAT=(Fl_Group *)0;

Fl_Output *txtXmlRigFilename=(Fl_Output *)0;

Fl_Button *btnSelectRigXmlFile=(Fl_Button *)0;

static void cb_btnSelectRigXmlFile(Fl_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
selectRigXmlFilename();
}

Fl_Input_Choice *inpXmlRigDevice=(Fl_Input_Choice *)0;

static void cb_inpXmlRigDevice(Fl_Input_Choice*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Value_Input2 *cntRigCatRetries=(Fl_Value_Input2 *)0;

static void cb_cntRigCatRetries(Fl_Value_Input2*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Value_Input2 *cntRigCatTimeout=(Fl_Value_Input2 *)0;

static void cb_cntRigCatTimeout(Fl_Value_Input2*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Value_Input2 *cntRigCatWait=(Fl_Value_Input2 *)0;

static void cb_cntRigCatWait(Fl_Value_Input2*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Choice *mnuXmlRigBaudrate=(Fl_Choice *)0;

static void cb_mnuXmlRigBaudrate(Fl_Choice*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Counter2 *valRigCatStopbits=(Fl_Counter2 *)0;

static void cb_valRigCatStopbits(Fl_Counter2*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
btnRevertRIGCAT->activate();
}

Fl_Button *btnInitRIGCAT=(Fl_Button *)0;

static void cb_btnInitRIGCAT(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Check_Button *btnRigCatEcho=(Fl_Check_Button *)0;

static void cb_btnRigCatEcho(Fl_Check_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
progdefaults.changed = true;
btnRevertRIGCAT->activate();
}

Fl_Round_Button *btnRigCatCMDptt=(Fl_Round_Button *)0;

static void cb_btnRigCatCMDptt(Fl_Round_Button* o, void*) {
  if (o->value()== 1) {
  btnRigCatRTSptt->value(0);
  btnRigCatDTRptt->value(0);
}
  
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
btnRevertRIGCAT->activate();
}

Fl_Round_Button *btnRigCatRTSptt=(Fl_Round_Button *)0;

static void cb_btnRigCatRTSptt(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
//  btnRigCatDTRptt->value(0);
  btnRigCatCMDptt->value(0);
}

btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Round_Button *btnRigCatDTRptt=(Fl_Round_Button *)0;

static void cb_btnRigCatDTRptt(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
//  btnRigCatRTSptt->value(0);
  btnRigCatCMDptt->value(0);
}

btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Check_Button *btnRigCatRTSplus=(Fl_Check_Button *)0;

static void cb_btnRigCatRTSplus(Fl_Check_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Check_Button *btnRigCatDTRplus=(Fl_Check_Button *)0;

static void cb_btnRigCatDTRplus(Fl_Check_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Check_Button *chkRigCatRTSCTSflow=(Fl_Check_Button *)0;

static void cb_chkRigCatRTSCTSflow(Fl_Check_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Button *btnRevertRIGCAT=(Fl_Button *)0;

static void cb_btnRevertRIGCAT(Fl_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_FOREGROUND_COLOR);
btnInitRIGCAT->redraw_label();
rigCAT_restore_defaults();
}

Fl_Check_Button *chkRigCatVSP=(Fl_Check_Button *)0;

static void cb_chkRigCatVSP(Fl_Check_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw_label();
btnRevertRIGCAT->activate();
}

Fl_Group *tabHamlib=(Fl_Group *)0;

Fl_Check_Button *chkUSEHAMLIB=(Fl_Check_Button *)0;

static void cb_chkUSEHAMLIB(Fl_Check_Button* o, void*) {
  progdefaults.chkUSEHAMLIBis = o->value();
if (o->value() == 1) {
  chkUSEMEMMAP->value(0);
  chkUSERIGCAT->value(0);
  chkUSEXMLRPC->value(0);
  progdefaults.chkUSEMEMMAPis = false;
  progdefaults.chkUSERIGCATis = false;
  progdefaults.chkUSEXMLRPCis = false;
}
  
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Group *grpHamlib=(Fl_Group *)0;

Fl_ComboBox *cboHamlibRig=(Fl_ComboBox *)0;

static void cb_cboHamlibRig(Fl_ComboBox*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
#if USE_HAMLIB
hamlib_get_defaults();
#endif
}

Fl_Input_Choice *inpRIGdev=(Fl_Input_Choice *)0;

static void cb_inpRIGdev(Fl_Input_Choice*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Value_Input2 *cntHamlibRetries=(Fl_Value_Input2 *)0;

static void cb_cntHamlibRetries(Fl_Value_Input2*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Value_Input2 *cntHamlibTimeout=(Fl_Value_Input2 *)0;

static void cb_cntHamlibTimeout(Fl_Value_Input2*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Value_Input2 *cntHamlibWriteDelay=(Fl_Value_Input2 *)0;

static void cb_cntHamlibWriteDelay(Fl_Value_Input2*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Value_Input2 *cntHamlibWait=(Fl_Value_Input2 *)0;

static void cb_cntHamlibWait(Fl_Value_Input2*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Choice *mnuBaudRate=(Fl_Choice *)0;

static void cb_mnuBaudRate(Fl_Choice*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Counter2 *valHamRigStopbits=(Fl_Counter2 *)0;

static void cb_valHamRigStopbits(Fl_Counter2* o, void*) {
  progdefaults.HamRigStopbits = (int)o->value();
btnRevertHAMLIB->activate();
progdefaults.changed = true;
}

Fl_Counter2 *cntHamlibTimeout0=(Fl_Counter2 *)0;

static void cb_cntHamlibTimeout0(Fl_Counter2* o, void*) {
  progdefaults.HamlibTimeout = (int)o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
}

Fl_Input2 *inpHamlibConfig=(Fl_Input2 *)0;

static void cb_inpHamlibConfig(Fl_Input2*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Button *btnInitHAMLIB=(Fl_Button *)0;

static void cb_btnInitHAMLIB(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
btnRevertHAMLIB->deactivate();
progdefaults.changed = true;
}

Fl_Choice *mnuSideband=(Fl_Choice *)0;

Fl_Round_Button *btnHamlibCMDptt=(Fl_Round_Button *)0;

static void cb_btnHamlibCMDptt(Fl_Round_Button*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Check_Button *btnHamlibDTRplus=(Fl_Check_Button *)0;

static void cb_btnHamlibDTRplus(Fl_Check_Button*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Check_Button *chkHamlibRTSplus=(Fl_Check_Button *)0;

static void cb_chkHamlibRTSplus(Fl_Check_Button* o, void*) {
  if (o->value() == 1)
  chkHamlibRTSCTSflow->value(0);
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Check_Button *chkHamlibRTSCTSflow=(Fl_Check_Button *)0;

static void cb_chkHamlibRTSCTSflow(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
  chkHamlibXONXOFFflow->value(0);
  chkHamlibRTSplus->deactivate();
} else
  chkHamlibRTSplus->activate();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Check_Button *chkHamlibXONXOFFflow=(Fl_Check_Button *)0;

static void cb_chkHamlibXONXOFFflow(Fl_Check_Button* o, void*) {
  if (o->value() == 1)
  chkHamlibRTSCTSflow->value(0);
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw_label();
btnRevertHAMLIB->activate();
}

Fl_Button *btnRevertHAMLIB=(Fl_Button *)0;

static void cb_btnRevertHAMLIB(Fl_Button*, void*) {
  btnInitHAMLIB->labelcolor(FL_FOREGROUND_COLOR);
btnInitHAMLIB->redraw_label();
#if USE_HAMLIB
hamlib_restore_defaults();
#endif
}

Fl_Group *grpMemmap=(Fl_Group *)0;

Fl_Check_Button *chkUSEMEMMAP=(Fl_Check_Button *)0;

static void cb_chkUSEMEMMAP(Fl_Check_Button* o, void*) {
  progdefaults.chkUSEMEMMAPis = o->value();
if(o->value() == 1){
  chkUSEHAMLIB->value(0);
  chkUSERIGCAT->value(0);
  chkUSEXMLRPC->value(0);
  progdefaults.chkUSEHAMLIBis = false;
  progdefaults.chkUSERIGCATis = false;
  progdefaults.chkUSEXMLRPCis = false;
}
  
btnInitMEMMAP->labelcolor(FL_RED);
btnInitMEMMAP->redraw_label();
progdefaults.changed = true;
}

Fl_Round_Button *btnMEMMAPptt=(Fl_Round_Button *)0;

static void cb_btnMEMMAPptt(Fl_Round_Button* o, void*) {
  progdefaults.MEMMAPptt=o->value();

btnInitMEMMAP->labelcolor(FL_RED);
btnInitMEMMAP->redraw_label();
progdefaults.changed = true;
}

Fl_Button *btnInitMEMMAP=(Fl_Button *)0;

static void cb_btnInitMEMMAP(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Group *tabXMLRPC=(Fl_Group *)0;

Fl_Group *grpXMLRPC=(Fl_Group *)0;

Fl_Check_Button *chkUSEXMLRPC=(Fl_Check_Button *)0;

static void cb_chkUSEXMLRPC(Fl_Check_Button* o, void*) {
  progdefaults.chkUSEXMLRPCis = o->value();
if(o->value() == 1){
  chkUSEHAMLIB->value(0);
  chkUSERIGCAT->value(0);
  chkUSEMEMMAP->value(0);
  progdefaults.chkUSEMEMMAPis = false;
  progdefaults.chkUSEHAMLIBis = false;
  progdefaults.chkUSERIGCATis = false;
}
  
btnInitXMLRPC->labelcolor(FL_RED);
btnInitXMLRPC->redraw_label();
progdefaults.changed = true;
}

Fl_Button *btnInitXMLRPC=(Fl_Button *)0;

static void cb_btnInitXMLRPC(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Group *tabSoundCard=(Fl_Group *)0;

Fl_Tabs *tabsSoundCard=(Fl_Tabs *)0;

Fl_Group *tabAudio=(Fl_Group *)0;

Fl_Group *AudioOSS=(Fl_Group *)0;

static void cb_btnAudioIO(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_OSS);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Input_Choice *menuOSSDev=(Fl_Input_Choice *)0;

static void cb_menuOSSDev(Fl_Input_Choice* o, void*) {
  scDevice[0] = scDevice[1] = progdefaults.OSSdevice = o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *AudioPort=(Fl_Group *)0;

static void cb_btnAudioIO1(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_PORT);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Choice *menuPortInDev=(Fl_Choice *)0;

static void cb_menuPortInDev(Fl_Choice* o, void*) {
  scDevice[0] = progdefaults.PortInDevice = o->text();
progdefaults.PortInIndex = reinterpret_cast<intptr_t>(o->mvalue()->user_data());
resetSoundCard();
progdefaults.changed = true;
}

Fl_Choice *menuPortOutDev=(Fl_Choice *)0;

static void cb_menuPortOutDev(Fl_Choice* o, void*) {
  scDevice[1] = progdefaults.PortOutDevice = o->text();
progdefaults.PortOutIndex = reinterpret_cast<intptr_t>(o->mvalue()->user_data());
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *AudioPulse=(Fl_Group *)0;

static void cb_btnAudioIO2(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_PULSE);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Input2 *inpPulseServer=(Fl_Input2 *)0;

static void cb_inpPulseServer(Fl_Input2* o, void*) {
  scDevice[0] = scDevice[1] = progdefaults.PulseServer = o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *AudioNull=(Fl_Group *)0;

Fl_Round_Button *btnAudioIO[4]={(Fl_Round_Button *)0};

static void cb_btnAudioIO3(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_NULL);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Group *tabAudioOpt=(Fl_Group *)0;

Fl_Group *grpAudioSampleRate=(Fl_Group *)0;

Fl_Choice *menuInSampleRate=(Fl_Choice *)0;

static void cb_menuInSampleRate(Fl_Choice* o, void*) {
  progdefaults.in_sample_rate = o->value() > 1 ? strtol(o->mvalue()->text, 0, 10) : o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Choice *menuOutSampleRate=(Fl_Choice *)0;

static void cb_menuOutSampleRate(Fl_Choice* o, void*) {
  progdefaults.out_sample_rate = o->value() > 1 ? strtol(o->mvalue()->text, 0, 10) : o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Choice *menuSampleConverter=(Fl_Choice *)0;

static void cb_menuSampleConverter(Fl_Choice* o, void*) {
  if (o->value() == FLDIGI_SRC_BEST)
    fl_alert2("The best quality SINC interpolator has very high CPU overhead");
progdefaults.sample_converter = sample_rate_converters[o->value()];
resetSoundCard();
progdefaults.changed = true;
o->tooltip(src_get_description(sample_rate_converters[o->value()]));
}

Fl_Spinner2 *cntRxRateCorr=(Fl_Spinner2 *)0;

static void cb_cntRxRateCorr(Fl_Spinner2* o, void*) {
  progdefaults.RX_corr = (int)o->value();
progdefaults.changed = true;
}

Fl_Spinner2 *cntTxRateCorr=(Fl_Spinner2 *)0;

static void cb_cntTxRateCorr(Fl_Spinner2* o, void*) {
  progdefaults.TX_corr = (int)o->value();
progdefaults.changed = true;
}

Fl_Spinner2 *cntTxOffset=(Fl_Spinner2 *)0;

static void cb_cntTxOffset(Fl_Spinner2* o, void*) {
  progdefaults.TxOffset = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkAudioStereoOut=(Fl_Check_Button *)0;

static void cb_chkAudioStereoOut(Fl_Check_Button* o, void*) {
  if (!o->value() && (progdefaults.PseudoFSK || progdefaults.QSK || progdefaults.PTTrightchannel))
    LOG_WARN("Disabling right audio channel while in use by the QSK, pseudo-FSK or audio PTT options");

progdefaults.out_channels = o->value() + 1;
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *tabMixer=(Fl_Group *)0;

Fl_Check_Button *btnMixer=(Fl_Check_Button *)0;

static void cb_btnMixer(Fl_Check_Button* o, void*) {
  enableMixer(o->value());
progdefaults.changed = true;
}

Fl_Input_Choice *menuMix=(Fl_Input_Choice *)0;

static void cb_menuMix(Fl_Input_Choice* o, void*) {
  progdefaults.MXdevice = o->value();
enableMixer(false);
enableMixer(true);
progdefaults.changed = true;
}

Fl_Light_Button *btnMicIn=(Fl_Light_Button *)0;

static void cb_btnMicIn(Fl_Light_Button* o, void*) {
  if (o->value() == 1) {
    btnLineIn->value(0);
    progdefaults.LineIn = false;
    progdefaults.MicIn = true;
    setMixerInput(2);
} else {
    setMixerInput(0);
    progdefaults.MicIn = false;
}
progdefaults.changed = true;
}

Fl_Light_Button *btnLineIn=(Fl_Light_Button *)0;

static void cb_btnLineIn(Fl_Light_Button* o, void*) {
  if (o->value() == 1) {
    btnMicIn->value(0);
    progdefaults.LineIn = true;
    progdefaults.MicIn = false;
    setMixerInput(1);
} else {
    setMixerInput(0);
    progdefaults.LineIn = false;
}
progdefaults.changed = true;
}

Fl_Value_Slider2 *valPCMvolume=(Fl_Value_Slider2 *)0;

static void cb_valPCMvolume(Fl_Value_Slider2* o, void*) {
  setPCMvolume(o->value());
progdefaults.changed = true;
}

Fl_Group *tabTxLevel=(Fl_Group *)0;

Fl_Counter *valTxLevel=(Fl_Counter *)0;

static void cb_valTxLevel(Fl_Counter* o, void*) {
  progdefaults.txlevel=o->value();
}

Fl_Group *tabID=(Fl_Group *)0;

Fl_Check_Button *btnsendid=(Fl_Check_Button *)0;

static void cb_btnsendid(Fl_Check_Button* o, void*) {
  progdefaults.sendid=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnsendvideotext=(Fl_Check_Button *)0;

static void cb_btnsendvideotext(Fl_Check_Button* o, void*) {
  progdefaults.sendtextid=o->value();
progdefaults.changed = true;
}

Fl_Input2 *valVideotext=(Fl_Input2 *)0;

static void cb_valVideotext(Fl_Input2* o, void*) {
  progdefaults.strTextid = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkID_SMALL=(Fl_Check_Button *)0;

static void cb_chkID_SMALL(Fl_Check_Button* o, void*) {
  progdefaults.ID_SMALL=o->value();
progdefaults.changed = true;
}

Fl_Value_Slider2 *sldrVideowidth=(Fl_Value_Slider2 *)0;

static void cb_sldrVideowidth(Fl_Value_Slider2* o, void*) {
  progdefaults.videowidth = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btn_vidlimit=(Fl_Check_Button *)0;

static void cb_btn_vidlimit(Fl_Check_Button* o, void*) {
  progdefaults.vidlimit=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btn_vidmodelimit=(Fl_Check_Button *)0;

static void cb_btn_vidmodelimit(Fl_Check_Button* o, void*) {
  progdefaults.vidmodelimit=o->value();
progdefaults.changed=true;
}

Fl_Button *bVideoIDModes=(Fl_Button *)0;

static void cb_bVideoIDModes(Fl_Button* o, void*) {
  mode_browser->label(o->label());
mode_browser->callback(0);
mode_browser->show(&progdefaults.videoid_modes);
progdefaults.changed = true;
}

Fl_Group *sld=(Fl_Group *)0;

Fl_Check_Button *btnCWID=(Fl_Check_Button *)0;

static void cb_btnCWID(Fl_Check_Button* o, void*) {
  progdefaults.CWid = o->value();
progdefaults.changed = true;
}

Fl_Value_Slider2 *sldrCWIDwpm=(Fl_Value_Slider2 *)0;

static void cb_sldrCWIDwpm(Fl_Value_Slider2* o, void*) {
  progdefaults.CWIDwpm = (int)o->value();
progdefaults.changed = true;
}

Fl_Button *bCWIDModes=(Fl_Button *)0;

static void cb_bCWIDModes(Fl_Button* o, void*) {
  mode_browser->label(o->label());
mode_browser->callback(0);
mode_browser->show(&progdefaults.cwid_modes);
progdefaults.changed = true;
}

Fl_Check_Button *chkRSidWideSearch=(Fl_Check_Button *)0;

static void cb_chkRSidWideSearch(Fl_Check_Button* o, void*) {
  progdefaults.rsidWideSearch=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkRSidMark=(Fl_Check_Button *)0;

static void cb_chkRSidMark(Fl_Check_Button* o, void*) {
  progdefaults.rsid_mark = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkRSidAutoDisable=(Fl_Check_Button *)0;

static void cb_chkRSidAutoDisable(Fl_Check_Button* o, void*) {
  progdefaults.rsid_auto_disable = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkRSidNotifyOnly=(Fl_Check_Button *)0;

static void cb_chkRSidNotifyOnly(Fl_Check_Button* o, void*) {
  progdefaults.rsid_notify_only = o->value();
notify_create_rsid_event(progdefaults.rsid_notify_only);
if (progdefaults.rsid_notify_only) {
    chkRSidAutoDisable->value(0);
    chkRSidAutoDisable->deactivate();
}
else
    chkRSidAutoDisable->activate();
progdefaults.changed = true;
}

Fl_Button *bRSIDRxModes=(Fl_Button *)0;

static void cb_bRSIDRxModes(Fl_Button* o, void*) {
  mode_browser->label(o->label());
mode_browser->callback(0);
mode_browser->show(&progdefaults.rsid_rx_modes);
progdefaults.changed = true;
}

Fl_Value_Slider2 *sldrRSIDsquelch=(Fl_Value_Slider2 *)0;

static void cb_sldrRSIDsquelch(Fl_Value_Slider2* o, void*) {
  progdefaults.rsid_squelch = (int)o->value();
progdefaults.changed = true;
}

Fl_Button *bRSIDTxModes=(Fl_Button *)0;

static void cb_bRSIDTxModes(Fl_Button* o, void*) {
  mode_browser->label(o->label());
mode_browser->callback(0);
mode_browser->show(&progdefaults.rsid_tx_modes);
progdefaults.changed = true;
}

Fl_Counter *val_pretone=(Fl_Counter *)0;

static void cb_val_pretone(Fl_Counter* o, void*) {
  progdefaults.pretone = o->value();
progdefaults.changed = true;
}

Fl_Group *tabMisc=(Fl_Group *)0;

Fl_Tabs *tabsMisc=(Fl_Tabs *)0;

Fl_Group *tabCPUspeed=(Fl_Group *)0;

Fl_Check_Button *chkSlowCpu=(Fl_Check_Button *)0;

static void cb_chkSlowCpu(Fl_Check_Button* o, void*) {
  progdefaults.slowcpu = o->value();
progdefaults.changed = true;
}

Fl_Group *tabNBEMS=(Fl_Group *)0;

Fl_Check_Button *chkAutoExtract=(Fl_Check_Button *)0;

static void cb_chkAutoExtract(Fl_Check_Button* o, void*) {
  progdefaults.autoextract = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chk_open_wrap_folder=(Fl_Check_Button *)0;

static void cb_chk_open_wrap_folder(Fl_Check_Button* o, void*) {
  progdefaults.open_nbems_folder = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chk_open_flmsg=(Fl_Check_Button *)0;

static void cb_chk_open_flmsg(Fl_Check_Button* o, void*) {
  progdefaults.open_flmsg = o->value();
progdefaults.changed = true;
}

Fl_Input2 *txt_flmsg_pathname=(Fl_Input2 *)0;

static void cb_txt_flmsg_pathname(Fl_Input2* o, void*) {
  progdefaults.flmsg_pathname = o->value();
progdefaults.changed = true;
}

Fl_Button *btn_select_flmsg=(Fl_Button *)0;

static void cb_btn_select_flmsg(Fl_Button*, void*) {
  select_flmsg_pathname();
}

Fl_Check_Button *chk_open_flmsg_print=(Fl_Check_Button *)0;

static void cb_chk_open_flmsg_print(Fl_Check_Button* o, void*) {
  progdefaults.open_flmsg_print = o->value();
progdefaults.changed = true;
}

Fl_Group *tabPskmail=(Fl_Group *)0;

Fl_Counter2 *cntServerCarrier=(Fl_Counter2 *)0;

static void cb_cntServerCarrier(Fl_Counter2* o, void*) {
  progdefaults.ServerCarrier = (int)o->value();
wf->redraw_marker();
progdefaults.changed = true;
}

Fl_Counter2 *cntServerOffset=(Fl_Counter2 *)0;

static void cb_cntServerOffset(Fl_Counter2* o, void*) {
  progdefaults.ServerOffset = (int)o->value();
wf->redraw_marker();
progdefaults.changed = true;
}

Fl_Counter2 *cntServerACQsn=(Fl_Counter2 *)0;

static void cb_cntServerACQsn(Fl_Counter2* o, void*) {
  progdefaults.ServerACQsn = o->value();
progdefaults.changed = true;
}

Fl_Counter2 *cntServerAFCrange=(Fl_Counter2 *)0;

static void cb_cntServerAFCrange(Fl_Counter2* o, void*) {
  progdefaults.ServerAFCrange = (int)o->value();
wf->redraw_marker();
progdefaults.changed = true;
}

Fl_Check_Button *btnPSKmailSweetSpot=(Fl_Check_Button *)0;

static void cb_btnPSKmailSweetSpot(Fl_Check_Button* o, void*) {
  progdefaults.PSKmailSweetSpot = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btn_arq_s2n_report=(Fl_Check_Button *)0;

static void cb_btn_arq_s2n_report(Fl_Check_Button* o, void*) {
  progdefaults.Pskmails2nreport=o->value();
}

Fl_Group *tabSpot=(Fl_Group *)0;

Fl_Check_Button *btnPSKRepAuto=(Fl_Check_Button *)0;

static void cb_btnPSKRepAuto(Fl_Check_Button* o, void*) {
  progdefaults.pskrep_auto = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Check_Button *btnPSKRepLog=(Fl_Check_Button *)0;

static void cb_btnPSKRepLog(Fl_Check_Button* o, void*) {
  progdefaults.pskrep_log = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Check_Button *btnPSKRepQRG=(Fl_Check_Button *)0;

static void cb_btnPSKRepQRG(Fl_Check_Button* o, void*) {
  progdefaults.pskrep_qrg = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpPSKRepHost=(Fl_Input2 *)0;

static void cb_inpPSKRepHost(Fl_Input2* o, void*) {
  progdefaults.pskrep_host = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Input2 *inpPSKRepPort=(Fl_Input2 *)0;

static void cb_inpPSKRepPort(Fl_Input2* o, void*) {
  progdefaults.pskrep_port = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Button *btnPSKRepInit=(Fl_Button *)0;

static void cb_btnPSKRepInit(Fl_Button* o, void*) {
  pskrep_stop();
if (!pskrep_start()) {
    boxPSKRepMsg->copy_label(pskrep_error());
    progdefaults.usepskrep = false;
} else {
    boxPSKRepMsg->label(0);
    o->labelcolor(FL_FOREGROUND_COLOR);
    progdefaults.usepskrep = true;
}
progdefaults.changed = true;
}

Fl_Box *boxPSKRepMsg=(Fl_Box *)0;

Fl_Group *tabSweetSpot=(Fl_Group *)0;

Fl_Value_Input2 *valCWsweetspot=(Fl_Value_Input2 *)0;

static void cb_valCWsweetspot(Fl_Value_Input2* o, void*) {
  progdefaults.CWsweetspot=o->value();
progdefaults.changed = true;
}

Fl_Value_Input2 *valRTTYsweetspot=(Fl_Value_Input2 *)0;

static void cb_valRTTYsweetspot(Fl_Value_Input2* o, void*) {
  progdefaults.RTTYsweetspot=o->value();
progdefaults.changed = true;
}

Fl_Value_Input2 *valPSKsweetspot=(Fl_Value_Input2 *)0;

static void cb_valPSKsweetspot(Fl_Value_Input2* o, void*) {
  progdefaults.PSKsweetspot=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnStartAtSweetSpot=(Fl_Check_Button *)0;

static void cb_btnStartAtSweetSpot(Fl_Check_Button* o, void*) {
  progdefaults.StartAtSweetSpot = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCWIsLSB=(Fl_Check_Button *)0;

static void cb_btnCWIsLSB(Fl_Check_Button* o, void*) {
  progdefaults.CWIsLSB=o->value();
progdefaults.changed=true;
}

Fl_Group *tabText_IO=(Fl_Group *)0;

Fl_Group *grpTalker=(Fl_Group *)0;

Fl_Light_Button *btnConnectTalker=(Fl_Light_Button *)0;

static void cb_btnConnectTalker(Fl_Light_Button* o, void*) {
  if (o->value()) open_talker();
else close_talker();
}

Fl_Check_Button *btn_auto_talk=(Fl_Check_Button *)0;

static void cb_btn_auto_talk(Fl_Check_Button* o, void*) {
  progdefaults.auto_talk = o->value();
}

Fl_Check_Button *chkRxStream=(Fl_Check_Button *)0;

static void cb_chkRxStream(Fl_Check_Button* o, void*) {
  progdefaults.speak = o->value();
progdefaults.changed = true;
}

Fl_Group *tabQRZ=(Fl_Group *)0;

Fl_Round_Button *btnQRZcdrom=(Fl_Round_Button *)0;

static void cb_btnQRZcdrom(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZCD;
progdefaults.changed = true;
}

Fl_Input2 *txtQRZpathname=(Fl_Input2 *)0;

static void cb_txtQRZpathname(Fl_Input2* o, void*) {
  progdefaults.QRZpathname = o->value();
progdefaults.QRZchanged = true;
progdefaults.changed = true;
}

Fl_Round_Button *btnQRZsub=(Fl_Round_Button *)0;

static void cb_btnQRZsub(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZNET;
progdefaults.changed = true;
}

Fl_Round_Button *btnHamcall=(Fl_Round_Button *)0;

static void cb_btnHamcall(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = HAMCALLNET;
progdefaults.changed = true;
}

Fl_Input2 *inpQRZusername=(Fl_Input2 *)0;

static void cb_inpQRZusername(Fl_Input2* o, void*) {
  progdefaults.QRZusername = o->value();
progdefaults.changed = true;
}

Fl_Input2 *inpQRZuserpassword=(Fl_Input2 *)0;

static void cb_inpQRZuserpassword(Fl_Input2* o, void*) {
  progdefaults.QRZuserpassword = o->value();
progdefaults.changed = true;
}

Fl_Button *btnQRZpasswordShow=(Fl_Button *)0;

static void cb_btnQRZpasswordShow(Fl_Button* o, void*) {
  inpQRZuserpassword->type(inpQRZuserpassword->type() ^ FL_SECRET_INPUT);
inpQRZuserpassword->redraw();
o->label((inpQRZuserpassword->type() & FL_SECRET_INPUT) ? "Show" : "Hide");
}

Fl_Round_Button *btnQRZnotavailable=(Fl_Round_Button *)0;

static void cb_btnQRZnotavailable(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZNONE;
progdefaults.changed = true;
}

Fl_Round_Button *btnQRZonline=(Fl_Round_Button *)0;

static void cb_btnQRZonline(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZHTML;
progdefaults.changed = true;
}

Fl_Round_Button *btnHAMCALLonline=(Fl_Round_Button *)0;

static void cb_btnHAMCALLonline(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = HAMCALLHTML;
progdefaults.changed = true;
}

Fl_Round_Button *btnCALLOOK=(Fl_Round_Button *)0;

static void cb_btnCALLOOK(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = CALLOOK;
progdefaults.changed = true;
}

Fl_Button *btnSaveConfig=(Fl_Button *)0;

static void cb_btnSaveConfig(Fl_Button*, void*) {
  progdefaults.saveDefaults();
}

Fl_Return_Button *btnCloseConfig=(Fl_Return_Button *)0;

static void cb_btnCloseConfig(Fl_Return_Button*, void*) {
  closeDialog();
}

Fl_Button *btnResetConfig=(Fl_Button *)0;

static void cb_btnResetConfig(Fl_Button*, void*) {
  progdefaults.resetDefaults();
progdefaults.changed = false;
}

Fl_Double_Window* ConfigureDialog() {
  Fl_Double_Window* w;
  static const char szShifts[]  = "23|85|160|170|182|200|240|350|425|_850|Custom";
static const char szBauds[]  = "45|45.45|50|56|75|100|110|150|200|300";
static const char szSelBits[] = "5 (baudot)|7 (ascii)|8 (ascii)";
static const char szParity[]  = "none|even|odd|zero|one";
static const char szStopBits[] = "1|1.5|2";
static const char szOliviaTones[] = "2|4|8|16|32|64|128|256";
static const char szOliviaBandwidth[] = "125|250|500|1000|2000";
static const char szContestiaTones[] = "2|4|8|16|32|64|128|256";
static const char szContestiaBandwidth[] = "125|250|500|1000|2000";
static const char szBaudRates[] = "300|600|1200|2400|4800|9600|19200|38400|57600|115200|230400|460800";
static const char szProsigns[] = "~|%|&|+|=|{|}|<|>|[|]| ";
  { Fl_Double_Window* o = new Fl_Double_Window(500, 400, _("Fldigi configuration"));
    w = o;
    o->color((Fl_Color)FL_DARK2);
    o->selection_color((Fl_Color)51);
    o->labelsize(18);
    o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    { tabsConfigure = new Fl_Tabs(-4, 0, 521, 372);
      tabsConfigure->color((Fl_Color)FL_LIGHT1);
      tabsConfigure->selection_color((Fl_Color)FL_LIGHT1);
      { tabOperator = new Fl_Group(0, 25, 500, 345, _("Operator"));
        tabOperator->tooltip(_("Operator information"));
        tabOperator->callback((Fl_Callback*)cb_tabOperator);
        tabOperator->when(FL_WHEN_CHANGED);
        tabOperator->hide();
        { Fl_Group* o = new Fl_Group(5, 35, 490, 165, _("Station"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { inpMyCallsign = new Fl_Input2(110, 64, 110, 24, _("Callsign:"));
            inpMyCallsign->tooltip(_("Operators callsign"));
            inpMyCallsign->box(FL_DOWN_BOX);
            inpMyCallsign->color((Fl_Color)FL_BACKGROUND2_COLOR);
            inpMyCallsign->selection_color((Fl_Color)FL_SELECTION_COLOR);
            inpMyCallsign->labeltype(FL_NORMAL_LABEL);
            inpMyCallsign->labelfont(0);
            inpMyCallsign->labelsize(14);
            inpMyCallsign->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            inpMyCallsign->callback((Fl_Callback*)cb_inpMyCallsign);
            inpMyCallsign->align(FL_ALIGN_LEFT);
            inpMyCallsign->when(FL_WHEN_RELEASE);
            inpMyCallsign->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* inpMyCallsign
          { inpMyName = new Fl_Input2(290, 64, 140, 24, _("Name:"));
            inpMyName->tooltip(_("Operators name"));
            inpMyName->box(FL_DOWN_BOX);
            inpMyName->color((Fl_Color)FL_BACKGROUND2_COLOR);
            inpMyName->selection_color((Fl_Color)FL_SELECTION_COLOR);
            inpMyName->labeltype(FL_NORMAL_LABEL);
            inpMyName->labelfont(0);
            inpMyName->labelsize(14);
            inpMyName->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            inpMyName->callback((Fl_Callback*)cb_inpMyName);
            inpMyName->align(FL_ALIGN_LEFT);
            inpMyName->when(FL_WHEN_RELEASE);
            inpMyName->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* inpMyName
          { inpMyQth = new Fl_Input2(110, 98, 320, 24, _("QTH:"));
            inpMyQth->tooltip(_("Operators QTH"));
            inpMyQth->box(FL_DOWN_BOX);
            inpMyQth->color((Fl_Color)FL_BACKGROUND2_COLOR);
            inpMyQth->selection_color((Fl_Color)FL_SELECTION_COLOR);
            inpMyQth->labeltype(FL_NORMAL_LABEL);
            inpMyQth->labelfont(0);
            inpMyQth->labelsize(14);
            inpMyQth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            inpMyQth->callback((Fl_Callback*)cb_inpMyQth);
            inpMyQth->align(FL_ALIGN_LEFT);
            inpMyQth->when(FL_WHEN_RELEASE);
            inpMyQth->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* inpMyQth
          { inpMyLocator = new Fl_Input2(110, 133, 85, 24, _("Locator:"));
            inpMyLocator->tooltip(_("Maidenhead locator as in EM64qv"));
            inpMyLocator->box(FL_DOWN_BOX);
            inpMyLocator->color((Fl_Color)FL_BACKGROUND2_COLOR);
            inpMyLocator->selection_color((Fl_Color)FL_SELECTION_COLOR);
            inpMyLocator->labeltype(FL_NORMAL_LABEL);
            inpMyLocator->labelfont(0);
            inpMyLocator->labelsize(14);
            inpMyLocator->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            inpMyLocator->callback((Fl_Callback*)cb_inpMyLocator);
            inpMyLocator->align(FL_ALIGN_LEFT);
            inpMyLocator->when(FL_WHEN_RELEASE);
            inpMyLocator->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* inpMyLocator
          o->end();
        } // Fl_Group* o
        { inpMyAntenna = new Fl_Input2(110, 167, 320, 24, _("Antenna:"));
          inpMyAntenna->tooltip(_("Short description of antenna"));
          inpMyAntenna->box(FL_DOWN_BOX);
          inpMyAntenna->color((Fl_Color)FL_BACKGROUND2_COLOR);
          inpMyAntenna->selection_color((Fl_Color)FL_SELECTION_COLOR);
          inpMyAntenna->labeltype(FL_NORMAL_LABEL);
          inpMyAntenna->labelfont(0);
          inpMyAntenna->labelsize(14);
          inpMyAntenna->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
          inpMyAntenna->callback((Fl_Callback*)cb_inpMyAntenna);
          inpMyAntenna->align(FL_ALIGN_LEFT);
          inpMyAntenna->when(FL_WHEN_RELEASE);
          inpMyAntenna->labelsize(FL_NORMAL_SIZE);
        } // Fl_Input2* inpMyAntenna
        { grpNoise = new Fl_Group(5, 203, 490, 165, _("Test Signal - Do NOT use with transmitter"));
          grpNoise->box(FL_ENGRAVED_FRAME);
          grpNoise->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          grpNoise->hide();
          { Fl_Check_Button* o = btnNoiseOn = new Fl_Check_Button(43, 241, 70, 15, _("Noise on"));
            btnNoiseOn->down_box(FL_DOWN_BOX);
            btnNoiseOn->callback((Fl_Callback*)cb_btnNoiseOn);
            o->value(progdefaults.noise);
          } // Fl_Check_Button* btnNoiseOn
          { Fl_Counter2* o = noiseDB = new Fl_Counter2(40, 279, 89, 21, _("dB"));
            noiseDB->type(1);
            noiseDB->box(FL_UP_BOX);
            noiseDB->color((Fl_Color)FL_BACKGROUND_COLOR);
            noiseDB->selection_color((Fl_Color)FL_INACTIVE_COLOR);
            noiseDB->labeltype(FL_NORMAL_LABEL);
            noiseDB->labelfont(0);
            noiseDB->labelsize(14);
            noiseDB->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            noiseDB->minimum(-18);
            noiseDB->maximum(60);
            noiseDB->step(1);
            noiseDB->value(20);
            noiseDB->callback((Fl_Callback*)cb_noiseDB);
            noiseDB->align(FL_ALIGN_LEFT);
            noiseDB->when(FL_WHEN_CHANGED);
            o->value(progdefaults.s2n);
          } // Fl_Counter2* noiseDB
          grpNoise->end();
        } // Fl_Group* grpNoise
        tabOperator->end();
      } // Fl_Group* tabOperator
      { tabUI = new Fl_Group(0, 25, 502, 346, _("UI"));
        tabUI->hide();
        { tabsUI = new Fl_Tabs(0, 25, 502, 346);
          tabsUI->selection_color((Fl_Color)FL_LIGHT1);
          { tabUserInterface = new Fl_Group(0, 50, 500, 320, _("Gen\'"));
            { Fl_Group* o = new Fl_Group(2, 55, 496, 59);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnShowTooltips = new Fl_Check_Button(20, 61, 120, 20, _("Show tooltips"));
                btnShowTooltips->tooltip(_("Enable / disable tooltips"));
                btnShowTooltips->down_box(FL_DOWN_BOX);
                btnShowTooltips->value(1);
                btnShowTooltips->callback((Fl_Callback*)cb_btnShowTooltips);
                o->value(progdefaults.tooltips);
              } // Fl_Check_Button* btnShowTooltips
              { Fl_Check_Button* o = chkMenuIcons = new Fl_Check_Button(155, 61, 150, 20, _("Show menu icons"));
                chkMenuIcons->tooltip(_("Enable / disable icons on menus"));
                chkMenuIcons->down_box(FL_DOWN_BOX);
                chkMenuIcons->callback((Fl_Callback*)cb_chkMenuIcons);
                o->value(progdefaults.menuicons);
              } // Fl_Check_Button* chkMenuIcons
              { mnuScheme = new Fl_Choice(155, 87, 80, 20, _("UI scheme"));
                mnuScheme->tooltip(_("Change application look and feel"));
                mnuScheme->down_box(FL_BORDER_BOX);
                mnuScheme->callback((Fl_Callback*)cb_mnuScheme);
                mnuScheme->align(FL_ALIGN_RIGHT);
                mnuScheme->add("base");
                mnuScheme->add("gtk+");
                mnuScheme->add("plastic");
                mnuScheme->value(mnuScheme->find_item(progdefaults.ui_scheme.c_str()));
              } // Fl_Choice* mnuScheme
              { bVisibleModes = new Fl_Button(20, 87, 110, 20, _("Visible modes"));
                bVisibleModes->tooltip(_("Select modes for menu access"));
                bVisibleModes->callback((Fl_Callback*)cb_bVisibleModes);
              } // Fl_Button* bVisibleModes
              { mnuLang = new Fl_Choice(365, 87, 110, 20, _("UI language"));
                mnuLang->tooltip(_("Changes take effect on next program startup"));
                mnuLang->down_box(FL_BORDER_BOX);
                mnuLang->callback((Fl_Callback*)cb_mnuLang);
                mnuLang->align(FL_ALIGN_TOP_LEFT);
              } // Fl_Choice* mnuLang
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(2, 114, 496, 150, _("QSO logging"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnNagMe = new Fl_Check_Button(19, 136, 236, 20, _("Prompt to save log"));
                btnNagMe->tooltip(_("Bug me about saving log entries"));
                btnNagMe->down_box(FL_DOWN_BOX);
                btnNagMe->callback((Fl_Callback*)cb_btnNagMe);
                o->value(progdefaults.NagMe);
              } // Fl_Check_Button* btnNagMe
              { Fl_Check_Button* o = btnClearOnSave = new Fl_Check_Button(19, 159, 236, 20, _("Clear on save"));
                btnClearOnSave->tooltip(_("Clear log entries after saving or using macro <LOG>"));
                btnClearOnSave->down_box(FL_DOWN_BOX);
                btnClearOnSave->callback((Fl_Callback*)cb_btnClearOnSave);
                o->value(progdefaults.ClearOnSave);
              } // Fl_Check_Button* btnClearOnSave
              { Fl_Check_Button* o = btnAutoFillQSO = new Fl_Check_Button(19, 182, 236, 20, _("Auto-fill Country and Azimuth"));
                btnAutoFillQSO->tooltip(_("Fill in Country / Azimuth using cty.dat information"));
                btnAutoFillQSO->down_box(FL_DOWN_BOX);
                btnAutoFillQSO->callback((Fl_Callback*)cb_btnAutoFillQSO);
                o->value(progdefaults.autofill_qso_fields);
              } // Fl_Check_Button* btnAutoFillQSO
              { Fl_Check_Button* o = btnCallUpperCase = new Fl_Check_Button(19, 205, 236, 20, _("Convert callsign to upper case"));
                btnCallUpperCase->tooltip(_("Force callsign field to UPPERCASE"));
                btnCallUpperCase->down_box(FL_DOWN_BOX);
                btnCallUpperCase->callback((Fl_Callback*)cb_btnCallUpperCase);
                o->value(progdefaults.calluppercase);
              } // Fl_Check_Button* btnCallUpperCase
              { Fl_Check_Button* o = btnDateTimeSort = new Fl_Check_Button(272, 136, 190, 20, _("Sort by Date/Time OFF"));
                btnDateTimeSort->tooltip(_("Sort by date/time OFF - effects all ADIF/Cabrillo reports"));
                btnDateTimeSort->down_box(FL_DOWN_BOX);
                btnDateTimeSort->callback((Fl_Callback*)cb_btnDateTimeSort);
                o->value(progdefaults.sort_date_time_off);
              } // Fl_Check_Button* btnDateTimeSort
              { Fl_Check_Button* o = btndate_time_force = new Fl_Check_Button(272, 159, 190, 20, _("Date time ON == OFF"));
                btndate_time_force->tooltip(_("Force date/time ON == date/time OFF"));
                btndate_time_force->down_box(FL_DOWN_BOX);
                btndate_time_force->callback((Fl_Callback*)cb_btndate_time_force);
                o->value(progdefaults.force_date_time);
              } // Fl_Check_Button* btndate_time_force
              { Fl_Input2* o = inpMyPower = new Fl_Input2(272, 182, 50, 24, _("Transmit Power"));
                inpMyPower->tooltip(_("Tx power used for logbook entries"));
                inpMyPower->box(FL_DOWN_BOX);
                inpMyPower->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpMyPower->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpMyPower->labeltype(FL_NORMAL_LABEL);
                inpMyPower->labelfont(0);
                inpMyPower->labelsize(14);
                inpMyPower->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpMyPower->callback((Fl_Callback*)cb_inpMyPower);
                inpMyPower->align(FL_ALIGN_RIGHT);
                inpMyPower->when(FL_WHEN_RELEASE);
                o->value(progdefaults.mytxpower.c_str());
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpMyPower
              { Fl_Check_Button* o = btnRSTdefault = new Fl_Check_Button(19, 228, 236, 20, _("Default RST out to 599"));
                btnRSTdefault->tooltip(_("Clear log controls sets RST out to 599"));
                btnRSTdefault->down_box(FL_DOWN_BOX);
                btnRSTdefault->callback((Fl_Callback*)cb_btnRSTdefault);
                o->value(progdefaults.RSTdefault);
              } // Fl_Check_Button* btnRSTdefault
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(2, 265, 496, 100, _("Text Capture"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnRXClicks = new Fl_Check_Button(19, 318, 313, 20, _("Double-click on RX text enters QSO data"));
                btnRXClicks->tooltip(_("Enable if you cannot use the middle mouse button"));
                btnRXClicks->down_box(FL_DOWN_BOX);
                btnRXClicks->callback((Fl_Callback*)cb_btnRXClicks);
                o->value(progdefaults.rxtext_clicks_qso_data);
              } // Fl_Check_Button* btnRXClicks
              { Fl_Check_Button* o = btnRXTooltips = new Fl_Check_Button(19, 340, 313, 20, _("Show callsign tooltips in received text"));
                btnRXTooltips->tooltip(_("Popup info after a 2 second hover on a callsign"));
                btnRXTooltips->down_box(FL_DOWN_BOX);
                btnRXTooltips->callback((Fl_Callback*)cb_btnRXTooltips);
                o->value(progdefaults.rxtext_tooltips);
              } // Fl_Check_Button* btnRXTooltips
              { Fl_Input2* o = inpNonword = new Fl_Input2(19, 286, 340, 24, _("Word delimiters"));
                inpNonword->tooltip(_("RX text QSO data entry is bounded by the non-word characters\ndefined here. T\
ab and newline are automatically included."));
                inpNonword->box(FL_DOWN_BOX);
                inpNonword->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpNonword->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpNonword->labeltype(FL_NORMAL_LABEL);
                inpNonword->labelfont(0);
                inpNonword->labelsize(14);
                inpNonword->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpNonword->textfont(4);
                inpNonword->callback((Fl_Callback*)cb_inpNonword);
                inpNonword->align(FL_ALIGN_RIGHT);
                inpNonword->when(FL_WHEN_RELEASE);
                o->value(progdefaults.nonwordchars.c_str());
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpNonword
              o->end();
            } // Fl_Group* o
            tabUserInterface->end();
          } // Fl_Group* tabUserInterface
          { tabBrowser = new Fl_Group(0, 50, 500, 320, _("Browser"));
            tabBrowser->hide();
            { Fl_Group* o = new Fl_Group(2, 59, 496, 300);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Spinner2* o = cntChannels = new Fl_Spinner2(18, 69, 50, 24, _("Channels, first channel starts at waterfall lower limit"));
                cntChannels->tooltip(_("Change # of psk viewer channels"));
                cntChannels->box(FL_NO_BOX);
                cntChannels->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntChannels->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                cntChannels->labeltype(FL_NORMAL_LABEL);
                cntChannels->labelfont(0);
                cntChannels->labelsize(14);
                cntChannels->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntChannels->maximum(30);
                cntChannels->value(30);
                cntChannels->callback((Fl_Callback*)cb_cntChannels);
                cntChannels->align(FL_ALIGN_RIGHT);
                cntChannels->when(FL_WHEN_RELEASE);
                o->minimum(5); o->maximum(30); o->step(1);
                o->value(progdefaults.VIEWERchannels);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* cntChannels
              { Fl_Spinner2* o = cntTimeout = new Fl_Spinner2(18, 105, 50, 24, _("Inactivity timeout"));
                cntTimeout->tooltip(_("Clear channel text after\n# seconds of inactivity"));
                cntTimeout->box(FL_NO_BOX);
                cntTimeout->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntTimeout->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                cntTimeout->labeltype(FL_NORMAL_LABEL);
                cntTimeout->labelfont(0);
                cntTimeout->labelsize(14);
                cntTimeout->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntTimeout->value(10);
                cntTimeout->callback((Fl_Callback*)cb_cntTimeout);
                cntTimeout->align(FL_ALIGN_RIGHT);
                cntTimeout->when(FL_WHEN_RELEASE);
                o->minimum(1); o->maximum(180); o->step(1);
                o->value(progdefaults.VIEWERtimeout);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* cntTimeout
              { mnuViewerLabel = new Fl_Choice(18, 145, 150, 24, _("Channel label"));
                mnuViewerLabel->tooltip(_("Appearance of label on each channel"));
                mnuViewerLabel->down_box(FL_BORDER_BOX);
                mnuViewerLabel->callback((Fl_Callback*)cb_mnuViewerLabel);
                mnuViewerLabel->align(FL_ALIGN_RIGHT);
                mnuViewerLabel->add(_("None")); mnuViewerLabel->add(_("Audio frequency"));
                mnuViewerLabel->add(_("Radio frequency")); mnuViewerLabel->add(_("Channel number"));
                mnuViewerLabel->value(progdefaults.VIEWERlabeltype);
              } // Fl_Choice* mnuViewerLabel
              { btnViewerFont = new Fl_Button(303, 145, 70, 24, _("Font..."));
                btnViewerFont->tooltip(_("select browser font"));
                btnViewerFont->callback((Fl_Callback*)cb_btnViewerFont);
              } // Fl_Button* btnViewerFont
              { Fl_Check_Button* o = btnFixedIntervals = new Fl_Check_Button(208, 131, 165, 20, _("Fixed Intervals"));
                btnFixedIntervals->tooltip(_("Force channel spacing to even 100 Hz increments"));
                btnFixedIntervals->down_box(FL_DOWN_BOX);
                btnFixedIntervals->value(1);
                btnFixedIntervals->callback((Fl_Callback*)cb_btnFixedIntervals);
                btnFixedIntervals->hide();
                o->value(progdefaults.VIEWERfixed);
              } // Fl_Check_Button* btnFixedIntervals
              { Fl_Check_Button* o = btnMarquee = new Fl_Check_Button(18, 183, 165, 20, _("Continuous scrolling"));
                btnMarquee->tooltip(_("ON - Marquee style\nOFF - Clear & restart"));
                btnMarquee->down_box(FL_DOWN_BOX);
                btnMarquee->callback((Fl_Callback*)cb_btnMarquee);
                o->value(progdefaults.VIEWERmarquee);
              } // Fl_Check_Button* btnMarquee
              { Fl_Check_Button* o = btnAscend = new Fl_Check_Button(18, 207, 253, 20, _("Lowest freq on bottom of viewer"));
                btnAscend->tooltip(_("Change positions of low to high channels"));
                btnAscend->down_box(FL_DOWN_BOX);
                btnAscend->callback((Fl_Callback*)cb_btnAscend);
                o->value(progdefaults.VIEWERascend);
              } // Fl_Check_Button* btnAscend
              { Fl_Check_Button* o = btnBrowserHistory = new Fl_Check_Button(18, 232, 356, 20, _("Play back history when active channel selected"));
                btnBrowserHistory->tooltip(_("Audio stream history decoded on selected signal"));
                btnBrowserHistory->down_box(FL_DOWN_BOX);
                btnBrowserHistory->callback((Fl_Callback*)cb_btnBrowserHistory);
                o->value(progdefaults.VIEWERhistory);
              } // Fl_Check_Button* btnBrowserHistory
              { Fl_Group* o = new Fl_Group(20, 265, 219, 60, _("Detection Level Colors"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
                { bwsrSliderColor = new Fl_Button(43, 288, 80, 24, _("Backgnd"));
                bwsrSliderColor->tooltip(_("Background color of signal viewer squelch control"));
                bwsrSliderColor->callback((Fl_Callback*)cb_bwsrSliderColor);
                bwsrSliderColor->color(fl_rgb_color(progdefaults.bwsrSliderColor.R, progdefaults.bwsrSliderColor.G,progdefaults.bwsrSliderColor.B));
                } // Fl_Button* bwsrSliderColor
                { bwsrSldrSelColor = new Fl_Button(135, 288, 80, 24, _("Button"));
                bwsrSldrSelColor->tooltip(_("Slider hilite color of signal viewer squelch control"));
                bwsrSldrSelColor->callback((Fl_Callback*)cb_bwsrSldrSelColor);
                bwsrSldrSelColor->color(fl_rgb_color(progdefaults.bwsrSldrSelColor.R, progdefaults.bwsrSldrSelColor.G,progdefaults.bwsrSliderColor.B));
                } // Fl_Button* bwsrSldrSelColor
                o->end();
              } // Fl_Group* o
              o->end();
            } // Fl_Group* o
            tabBrowser->end();
          } // Fl_Group* tabBrowser
          { tabMBars = new Fl_Group(0, 50, 500, 320, _("Macros"));
            tabMBars->hide();
            { Fl_Group* o = new Fl_Group(2, 250, 496, 40);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnMacroMouseWheel = new Fl_Check_Button(12, 259, 296, 20, _("Mouse wheel active on macro buttons"));
                btnMacroMouseWheel->tooltip(_("enable mouse wheel control of macro bar"));
                btnMacroMouseWheel->down_box(FL_DOWN_BOX);
                btnMacroMouseWheel->callback((Fl_Callback*)cb_btnMacroMouseWheel);
                o->value(progdefaults.macro_wheel);
              } // Fl_Check_Button* btnMacroMouseWheel
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(2, 54, 496, 195, _("Number and position of macro bars"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { btn_oneA = new Fl_Round_Button(12, 84, 220, 20, _("One bar (above waterfall)"));
                btn_oneA->type(102);
                btn_oneA->down_box(FL_ROUND_DOWN_BOX);
                btn_oneA->callback((Fl_Callback*)cb_btn_oneA);
              } // Fl_Round_Button* btn_oneA
              { btn_oneB = new Fl_Round_Button(12, 114, 220, 20, _("One bar (below waterfall)"));
                btn_oneB->type(102);
                btn_oneB->down_box(FL_ROUND_DOWN_BOX);
                btn_oneB->callback((Fl_Callback*)cb_btn_oneB);
              } // Fl_Round_Button* btn_oneB
              { btn_twoA = new Fl_Round_Button(12, 144, 220, 20, _("Two bars (scheme 1)"));
                btn_twoA->type(102);
                btn_twoA->down_box(FL_ROUND_DOWN_BOX);
                btn_twoA->callback((Fl_Callback*)cb_btn_twoA);
              } // Fl_Round_Button* btn_twoA
              { btn_twoB = new Fl_Round_Button(242, 144, 219, 20, _("Two bars (scheme 2)"));
                btn_twoB->type(102);
                btn_twoB->down_box(FL_ROUND_DOWN_BOX);
                btn_twoB->callback((Fl_Callback*)cb_btn_twoB);
              } // Fl_Round_Button* btn_twoB
              { btn_twoC = new Fl_Round_Button(12, 174, 220, 20, _("Two bars (scheme 3)"));
                btn_twoC->type(102);
                btn_twoC->down_box(FL_ROUND_DOWN_BOX);
                btn_twoC->callback((Fl_Callback*)cb_btn_twoC);
              } // Fl_Round_Button* btn_twoC
              { btn_twoD = new Fl_Round_Button(242, 174, 220, 20, _("Two bars (scheme 4)"));
                btn_twoD->type(102);
                btn_twoD->down_box(FL_ROUND_DOWN_BOX);
                btn_twoD->callback((Fl_Callback*)cb_btn_twoD);
              } // Fl_Round_Button* btn_twoD
              { btn_twoE = new Fl_Round_Button(12, 204, 220, 20, _("Two bars (scheme 5)"));
                btn_twoE->type(102);
                btn_twoE->down_box(FL_ROUND_DOWN_BOX);
                btn_twoE->callback((Fl_Callback*)cb_btn_twoE);
              } // Fl_Round_Button* btn_twoE
              { btn_twoF = new Fl_Round_Button(242, 204, 220, 20, _("Two bars (scheme 6)"));
                btn_twoF->type(102);
                btn_twoF->down_box(FL_ROUND_DOWN_BOX);
                btn_twoF->callback((Fl_Callback*)cb_btn_twoF);
              } // Fl_Round_Button* btn_twoF
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(2, 292, 496, 76);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnUseLastMacro = new Fl_Check_Button(12, 302, 277, 20, _("Load last used macro file on startup"));
                btnUseLastMacro->tooltip(_("ON - use last set of macros\nOFF - use default set"));
                btnUseLastMacro->down_box(FL_DOWN_BOX);
                btnUseLastMacro->callback((Fl_Callback*)cb_btnUseLastMacro);
                o->value(progdefaults.UseLastMacro);
              } // Fl_Check_Button* btnUseLastMacro
              { Fl_Check_Button* o = btnDisplayMacroFilename = new Fl_Check_Button(12, 331, 277, 20, _("Display macro filename on startup"));
                btnDisplayMacroFilename->tooltip(_("The filename is written to the RX text area"));
                btnDisplayMacroFilename->down_box(FL_DOWN_BOX);
                btnDisplayMacroFilename->callback((Fl_Callback*)cb_btnDisplayMacroFilename);
                o->value(progdefaults.DisplayMacroFilename);
              } // Fl_Check_Button* btnDisplayMacroFilename
              o->end();
            } // Fl_Group* o
            tabMBars->end();
          } // Fl_Group* tabMBars
          { tabContest = new Fl_Group(0, 50, 500, 320, _("Contest"));
            tabContest->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 80, _("Exchanges"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { lblSend = new Fl_Box(37, 95, 55, 20, _("Send:"));
              } // Fl_Box* lblSend
              { Fl_Input2* o = inpSend1 = new Fl_Input2(95, 95, 140, 20, _("Exchange Out"));
                inpSend1->tooltip(_("free form exchange"));
                inpSend1->box(FL_DOWN_BOX);
                inpSend1->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpSend1->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpSend1->labeltype(FL_NORMAL_LABEL);
                inpSend1->labelfont(0);
                inpSend1->labelsize(14);
                inpSend1->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpSend1->callback((Fl_Callback*)cb_inpSend1);
                inpSend1->align(FL_ALIGN_TOP);
                inpSend1->when(FL_WHEN_RELEASE);
                o->value(progdefaults.myXchg.c_str());
                inpSend1->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpSend1
              { Fl_Check_Button* o = btn599 = new Fl_Check_Button(310, 80, 130, 20, _("RST always 599"));
                btn599->tooltip(_("Force RST in/out to 599"));
                btn599->down_box(FL_DOWN_BOX);
                btn599->callback((Fl_Callback*)cb_btn599);
                o->value(progdefaults.fixed599);
              } // Fl_Check_Button* btn599
              { Fl_Check_Button* o = btnCutNbrs = new Fl_Check_Button(310, 110, 180, 20, _("Send CW cut numbers"));
                btnCutNbrs->tooltip(_("0 = T; 9 = N"));
                btnCutNbrs->down_box(FL_DOWN_BOX);
                btnCutNbrs->callback((Fl_Callback*)cb_btnCutNbrs);
                o->value(progdefaults.cutnbrs);
              } // Fl_Check_Button* btnCutNbrs
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 150, 490, 65, _("Serial number"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { btnUseLeadingZeros = new Fl_Check_Button(26, 176, 154, 20, _("Use leading zeros"));
                btnUseLeadingZeros->tooltip(_("Insert leading zeros into Xmtd serial number"));
                btnUseLeadingZeros->down_box(FL_DOWN_BOX);
                btnUseLeadingZeros->value(1);
                btnUseLeadingZeros->callback((Fl_Callback*)cb_btnUseLeadingZeros);
              } // Fl_Check_Button* btnUseLeadingZeros
              { Fl_Value_Input2* o = nbrContestStart = new Fl_Value_Input2(221, 176, 45, 20, _("Start"));
                nbrContestStart->tooltip(_("Starting number"));
                nbrContestStart->box(FL_DOWN_BOX);
                nbrContestStart->color((Fl_Color)FL_BACKGROUND2_COLOR);
                nbrContestStart->selection_color((Fl_Color)FL_SELECTION_COLOR);
                nbrContestStart->labeltype(FL_NORMAL_LABEL);
                nbrContestStart->labelfont(0);
                nbrContestStart->labelsize(14);
                nbrContestStart->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                nbrContestStart->maximum(10000);
                nbrContestStart->step(1);
                nbrContestStart->callback((Fl_Callback*)cb_nbrContestStart);
                nbrContestStart->align(FL_ALIGN_TOP);
                nbrContestStart->when(FL_WHEN_CHANGED);
                o->value(progdefaults.ContestStart);
              } // Fl_Value_Input2* nbrContestStart
              { nbrContestDigits = new Fl_Value_Input2(303, 175, 45, 20, _("Digits"));
                nbrContestDigits->tooltip(_("Number of digits in serial number"));
                nbrContestDigits->box(FL_DOWN_BOX);
                nbrContestDigits->color((Fl_Color)FL_BACKGROUND2_COLOR);
                nbrContestDigits->selection_color((Fl_Color)FL_SELECTION_COLOR);
                nbrContestDigits->labeltype(FL_NORMAL_LABEL);
                nbrContestDigits->labelfont(0);
                nbrContestDigits->labelsize(14);
                nbrContestDigits->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                nbrContestDigits->minimum(1);
                nbrContestDigits->maximum(5);
                nbrContestDigits->step(1);
                nbrContestDigits->value(3);
                nbrContestDigits->callback((Fl_Callback*)cb_nbrContestDigits);
                nbrContestDigits->align(FL_ALIGN_TOP);
                nbrContestDigits->when(FL_WHEN_CHANGED);
              } // Fl_Value_Input2* nbrContestDigits
              { btnResetSerNbr = new Fl_Button(395, 176, 70, 20, _("Reset"));
                btnResetSerNbr->tooltip(_("Initialize the QSO logging fields"));
                btnResetSerNbr->callback((Fl_Callback*)cb_btnResetSerNbr);
              } // Fl_Button* btnResetSerNbr
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 225, 490, 130, _("Duplicate check, CALL plus"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Light_Button* o = btnDupCheckOn = new Fl_Light_Button(15, 255, 74, 20, _("On/Off"));
                btnDupCheckOn->tooltip(_("Check for duplicates"));
                btnDupCheckOn->selection_color((Fl_Color)2);
                btnDupCheckOn->callback((Fl_Callback*)cb_btnDupCheckOn);
                o->value(progdefaults.EnableDupCheck);
              } // Fl_Light_Button* btnDupCheckOn
              { Fl_Check_Button* o = btnDupBand = new Fl_Check_Button(156, 255, 70, 20, _("Band"));
                btnDupBand->tooltip(_("Bands must match"));
                btnDupBand->down_box(FL_DOWN_BOX);
                btnDupBand->callback((Fl_Callback*)cb_btnDupBand);
                o->value(progdefaults.dupband);
              } // Fl_Check_Button* btnDupBand
              { Fl_Check_Button* o = btnDupMode = new Fl_Check_Button(276, 255, 70, 20, _("Mode"));
                btnDupMode->tooltip(_("Mode must match"));
                btnDupMode->down_box(FL_DOWN_BOX);
                btnDupMode->callback((Fl_Callback*)cb_btnDupMode);
                o->value(progdefaults.dupmode);
              } // Fl_Check_Button* btnDupMode
              { Fl_Check_Button* o = btnDupState = new Fl_Check_Button(395, 255, 70, 20, _("State"));
                btnDupState->tooltip(_("State must match"));
                btnDupState->down_box(FL_DOWN_BOX);
                btnDupState->callback((Fl_Callback*)cb_btnDupState);
                o->value(progdefaults.dupstate);
              } // Fl_Check_Button* btnDupState
              { Fl_Check_Button* o = btnDupXchg1 = new Fl_Check_Button(156, 283, 105, 20, _("Exchange In"));
                btnDupXchg1->tooltip(_("free form 1 must match"));
                btnDupXchg1->down_box(FL_DOWN_BOX);
                btnDupXchg1->callback((Fl_Callback*)cb_btnDupXchg1);
                o->value(progdefaults.dupxchg1);
              } // Fl_Check_Button* btnDupXchg1
              { Fl_Check_Button* o = btnDupTimeSpan = new Fl_Check_Button(156, 313, 129, 20, _("Time span over"));
                btnDupTimeSpan->tooltip(_("QSO must not occur within a time period of"));
                btnDupTimeSpan->down_box(FL_DOWN_BOX);
                btnDupTimeSpan->callback((Fl_Callback*)cb_btnDupTimeSpan);
                o->value(progdefaults.duptimespan);
              } // Fl_Check_Button* btnDupTimeSpan
              { Fl_Value_Input2* o = nbrTimeSpan = new Fl_Value_Input2(285, 313, 53, 20, _("minutes"));
                nbrTimeSpan->tooltip(_("Enter time span in minutes"));
                nbrTimeSpan->box(FL_DOWN_BOX);
                nbrTimeSpan->color((Fl_Color)FL_BACKGROUND2_COLOR);
                nbrTimeSpan->selection_color((Fl_Color)FL_SELECTION_COLOR);
                nbrTimeSpan->labeltype(FL_NORMAL_LABEL);
                nbrTimeSpan->labelfont(0);
                nbrTimeSpan->labelsize(14);
                nbrTimeSpan->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                nbrTimeSpan->maximum(1440);
                nbrTimeSpan->step(1);
                nbrTimeSpan->value(120);
                nbrTimeSpan->callback((Fl_Callback*)cb_nbrTimeSpan);
                nbrTimeSpan->align(FL_ALIGN_RIGHT);
                nbrTimeSpan->when(FL_WHEN_CHANGED);
                o->value(progdefaults.timespan);
              } // Fl_Value_Input2* nbrTimeSpan
              { Fl_Button* o = btnDupColor = new Fl_Button(15, 282, 90, 22, _("Dup Color"));
                btnDupColor->tooltip(_("Left click to select dup color"));
                btnDupColor->box(FL_DOWN_BOX);
                btnDupColor->down_box(FL_DOWN_BOX);
                btnDupColor->color((Fl_Color)FL_BACKGROUND2_COLOR);
                btnDupColor->selection_color((Fl_Color)FL_BACKGROUND2_COLOR);
                btnDupColor->callback((Fl_Callback*)cb_btnDupColor);
                o->color(fl_rgb_color(progdefaults.dup_color.R, progdefaults.dup_color.G, progdefaults.dup_color.B));
              } // Fl_Button* btnDupColor
              o->end();
            } // Fl_Group* o
            tabContest->end();
          } // Fl_Group* tabContest
          { tabWF_UI = new Fl_Group(0, 50, 500, 320, _("WF Ctrls"));
            tabWF_UI->hide();
            { Fl_Group* o = new Fl_Group(2, 58, 496, 253);
              o->box(FL_ENGRAVED_BOX);
              { Fl_Box* o = new Fl_Box(31, 65, 446, 25, _("Enable check box to show each respective operator control"));
                o->box(FL_FLAT_BOX);
                o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              } // Fl_Box* o
              { Fl_Check_Button* o = btnWF_UIrev = new Fl_Check_Button(58, 98, 150, 20, _("Reverse"));
                btnWF_UIrev->down_box(FL_DOWN_BOX);
                btnWF_UIrev->value(1);
                btnWF_UIrev->callback((Fl_Callback*)cb_btnWF_UIrev);
                o->value(progdefaults.WF_UIrev);
              } // Fl_Check_Button* btnWF_UIrev
              { Fl_Check_Button* o = btnWF_UIx1 = new Fl_Check_Button(277, 98, 162, 20, _("WF Magnification"));
                btnWF_UIx1->down_box(FL_DOWN_BOX);
                btnWF_UIx1->value(1);
                btnWF_UIx1->callback((Fl_Callback*)cb_btnWF_UIx1);
                o->value(progdefaults.WF_UIx1);
              } // Fl_Check_Button* btnWF_UIx1
              { Fl_Check_Button* o = btnWF_UIwfcarrier = new Fl_Check_Button(58, 129, 150, 20, _("WF carrier"));
                btnWF_UIwfcarrier->down_box(FL_DOWN_BOX);
                btnWF_UIwfcarrier->value(1);
                btnWF_UIwfcarrier->callback((Fl_Callback*)cb_btnWF_UIwfcarrier);
                o->value(progdefaults.WF_UIwfcarrier);
              } // Fl_Check_Button* btnWF_UIwfcarrier
              { Fl_Check_Button* o = btnWF_UIwfshift = new Fl_Check_Button(277, 129, 150, 20, _("WF Shift Controls"));
                btnWF_UIwfshift->down_box(FL_DOWN_BOX);
                btnWF_UIwfshift->value(1);
                btnWF_UIwfshift->callback((Fl_Callback*)cb_btnWF_UIwfshift);
                o->value(progdefaults.WF_UIwfshift);
              } // Fl_Check_Button* btnWF_UIwfshift
              { Fl_Check_Button* o = btnWF_UIwfreflevel = new Fl_Check_Button(58, 161, 150, 20, _("WF ref level"));
                btnWF_UIwfreflevel->down_box(FL_DOWN_BOX);
                btnWF_UIwfreflevel->value(1);
                btnWF_UIwfreflevel->callback((Fl_Callback*)cb_btnWF_UIwfreflevel);
                o->value(progdefaults.WF_UIwfreflevel);
              } // Fl_Check_Button* btnWF_UIwfreflevel
              { Fl_Check_Button* o = btnWF_UIwfdrop = new Fl_Check_Button(277, 161, 150, 20, _("WF drop rate"));
                btnWF_UIwfdrop->down_box(FL_DOWN_BOX);
                btnWF_UIwfdrop->value(1);
                btnWF_UIwfdrop->callback((Fl_Callback*)cb_btnWF_UIwfdrop);
                o->value(progdefaults.WF_UIwfdrop);
              } // Fl_Check_Button* btnWF_UIwfdrop
              { Fl_Check_Button* o = btnWF_UIwfampspan = new Fl_Check_Button(58, 193, 150, 20, _("WF amp span"));
                btnWF_UIwfampspan->down_box(FL_DOWN_BOX);
                btnWF_UIwfampspan->value(1);
                btnWF_UIwfampspan->callback((Fl_Callback*)cb_btnWF_UIwfampspan);
                o->value(progdefaults.WF_UIwfampspan);
              } // Fl_Check_Button* btnWF_UIwfampspan
              { Fl_Check_Button* o = btnWF_UIwfstore = new Fl_Check_Button(277, 193, 150, 20, _("WF Store"));
                btnWF_UIwfstore->down_box(FL_DOWN_BOX);
                btnWF_UIwfstore->value(1);
                btnWF_UIwfstore->callback((Fl_Callback*)cb_btnWF_UIwfstore);
                o->value(progdefaults.WF_UIwfstore);
              } // Fl_Check_Button* btnWF_UIwfstore
              { Fl_Check_Button* o = btnWF_UIwfmode = new Fl_Check_Button(58, 225, 150, 20, _("WF mode"));
                btnWF_UIwfmode->down_box(FL_DOWN_BOX);
                btnWF_UIwfmode->value(1);
                btnWF_UIwfmode->callback((Fl_Callback*)cb_btnWF_UIwfmode);
                o->value(progdefaults.WF_UIwfmode);
              } // Fl_Check_Button* btnWF_UIwfmode
              { Fl_Check_Button* o = btnWF_UIqsy = new Fl_Check_Button(277, 225, 150, 20, _("QSY"));
                btnWF_UIqsy->down_box(FL_DOWN_BOX);
                btnWF_UIqsy->value(1);
                btnWF_UIqsy->callback((Fl_Callback*)cb_btnWF_UIqsy);
                o->value(progdefaults.WF_UIqsy);
              } // Fl_Check_Button* btnWF_UIqsy
              { Fl_Check_Button* o = btnWF_UIxmtlock = new Fl_Check_Button(277, 257, 150, 20, _("XMT lock"));
                btnWF_UIxmtlock->down_box(FL_DOWN_BOX);
                btnWF_UIxmtlock->value(1);
                btnWF_UIxmtlock->callback((Fl_Callback*)cb_btnWF_UIxmtlock);
                o->value(progdefaults.WF_UIxmtlock);
              } // Fl_Check_Button* btnWF_UIxmtlock
              { btn_wf_enable_all = new Fl_Button(102, 280, 88, 20, _("Enable all"));
                btn_wf_enable_all->callback((Fl_Callback*)cb_btn_wf_enable_all);
              } // Fl_Button* btn_wf_enable_all
              { btn_wf_disable_all = new Fl_Button(301, 280, 88, 20, _("Disable all"));
                btn_wf_disable_all->callback((Fl_Callback*)cb_btn_wf_disable_all);
              } // Fl_Button* btn_wf_disable_all
              o->end();
            } // Fl_Group* o
            tabWF_UI->end();
          } // Fl_Group* tabWF_UI
          { tabRxText = new Fl_Group(0, 50, 500, 320, _("Rx Text"));
            tabRxText->hide();
            { Fl_Check_Button* o = btn_rx_lowercase = new Fl_Check_Button(27, 75, 389, 20, _("Print CW / RTTY / THROB / CONTESTIA in lowercase"));
              btn_rx_lowercase->down_box(FL_DOWN_BOX);
              btn_rx_lowercase->callback((Fl_Callback*)cb_btn_rx_lowercase);
              o->value(progdefaults.rx_lowercase);
            } // Fl_Check_Button* btn_rx_lowercase
            tabRxText->end();
          } // Fl_Group* tabRxText
          { tabLogServer = new Fl_Group(0, 50, 500, 320, _("Log server"));
            tabLogServer->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 147, _("Client/Server Logbook"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Input* o = xmllogServerAddress = new Fl_Input(139, 85, 180, 25, _("Server Address:"));
                xmllogServerAddress->tooltip(_("Enter URL address of server"));
                xmllogServerAddress->callback((Fl_Callback*)cb_xmllogServerAddress);
                o->value(progdefaults.xmllog_address.c_str());
              } // Fl_Input* xmllogServerAddress
              { Fl_Input* o = xmllogServerPort = new Fl_Input(139, 121, 98, 25, _("Server Port:"));
                xmllogServerPort->tooltip(_("Enter Port # assigned to server"));
                xmllogServerPort->callback((Fl_Callback*)cb_xmllogServerPort);
                o->value(progdefaults.xmllog_port.c_str());
              } // Fl_Input* xmllogServerPort
              { btn_reconnect_log_server = new Fl_Button(194, 156, 115, 26, _("Reconnect"));
                btn_reconnect_log_server->callback((Fl_Callback*)cb_btn_reconnect_log_server);
              } // Fl_Button* btn_reconnect_log_server
              o->end();
            } // Fl_Group* o
            tabLogServer->end();
          } // Fl_Group* tabLogServer
          tabsUI->end();
        } // Fl_Tabs* tabsUI
        tabUI->end();
      } // Fl_Group* tabUI
      { tabWaterfall = new Fl_Group(0, 25, 501, 347, _("Waterfall"));
        { tabsWaterfall = new Fl_Tabs(0, 25, 501, 347);
          tabsWaterfall->color((Fl_Color)FL_LIGHT1);
          tabsWaterfall->selection_color((Fl_Color)FL_LIGHT1);
          { Fl_Group* o = new Fl_Group(0, 50, 501, 320, _("Display"));
            { Fl_Group* o = new Fl_Group(5, 60, 496, 162, _("Colors and cursors"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { colorbox* o = WF_Palette = new colorbox(15, 93, 260, 24, _("aa"));
                WF_Palette->box(FL_DOWN_BOX);
                WF_Palette->color((Fl_Color)FL_FOREGROUND_COLOR);
                WF_Palette->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                WF_Palette->labeltype(FL_NORMAL_LABEL);
                WF_Palette->labelfont(0);
                WF_Palette->labelsize(12);
                WF_Palette->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                WF_Palette->callback((Fl_Callback*)cb_WF_Palette);
                WF_Palette->align(FL_ALIGN_TOP_LEFT);
                WF_Palette->when(FL_WHEN_RELEASE);
                o->label(progdefaults.PaletteName.c_str());
                o->labelsize(FL_NORMAL_SIZE);
              } // colorbox* WF_Palette
              { btnColor[0] = new Fl_Button(15, 120, 20, 24);
                btnColor[0]->tooltip(_("Change color"));
                btnColor[0]->callback((Fl_Callback*)cb_btnColor);
              } // Fl_Button* btnColor[0]
              { btnColor[1] = new Fl_Button(45, 120, 20, 24);
                btnColor[1]->tooltip(_("Change color"));
                btnColor[1]->callback((Fl_Callback*)cb_btnColor1);
              } // Fl_Button* btnColor[1]
              { btnColor[2] = new Fl_Button(75, 120, 20, 24);
                btnColor[2]->tooltip(_("Change color"));
                btnColor[2]->callback((Fl_Callback*)cb_btnColor2);
              } // Fl_Button* btnColor[2]
              { btnColor[3] = new Fl_Button(105, 120, 20, 24);
                btnColor[3]->tooltip(_("Change color"));
                btnColor[3]->callback((Fl_Callback*)cb_btnColor3);
              } // Fl_Button* btnColor[3]
              { btnColor[4] = new Fl_Button(135, 120, 20, 24);
                btnColor[4]->tooltip(_("Change color"));
                btnColor[4]->callback((Fl_Callback*)cb_btnColor4);
              } // Fl_Button* btnColor[4]
              { btnColor[5] = new Fl_Button(165, 120, 20, 24);
                btnColor[5]->tooltip(_("Change color"));
                btnColor[5]->callback((Fl_Callback*)cb_btnColor5);
              } // Fl_Button* btnColor[5]
              { btnColor[6] = new Fl_Button(195, 120, 20, 24);
                btnColor[6]->tooltip(_("Change color"));
                btnColor[6]->callback((Fl_Callback*)cb_btnColor6);
              } // Fl_Button* btnColor[6]
              { btnColor[7] = new Fl_Button(225, 120, 20, 24);
                btnColor[7]->tooltip(_("Change color"));
                btnColor[7]->callback((Fl_Callback*)cb_btnColor7);
              } // Fl_Button* btnColor[7]
              { btnColor[8] = new Fl_Button(256, 120, 20, 24);
                btnColor[8]->tooltip(_("Change color"));
                btnColor[8]->callback((Fl_Callback*)cb_btnColor8);
              } // Fl_Button* btnColor[8]
              { btnLoadPalette = new Fl_Button(314, 93, 70, 24, _("Load..."));
                btnLoadPalette->tooltip(_("Load a new palette"));
                btnLoadPalette->callback((Fl_Callback*)cb_btnLoadPalette);
              } // Fl_Button* btnLoadPalette
              { btnSavePalette = new Fl_Button(314, 120, 70, 24, _("Save..."));
                btnSavePalette->tooltip(_("Save this palette"));
                btnSavePalette->callback((Fl_Callback*)cb_btnSavePalette);
              } // Fl_Button* btnSavePalette
              { Fl_Check_Button* o = btnUseCursorLines = new Fl_Check_Button(15, 149, 150, 20, _("Bandwidth cursor"));
                btnUseCursorLines->tooltip(_("Show cursor with bandwidth lines"));
                btnUseCursorLines->down_box(FL_DOWN_BOX);
                btnUseCursorLines->callback((Fl_Callback*)cb_btnUseCursorLines);
                o->value(progdefaults.UseCursorLines);
              } // Fl_Check_Button* btnUseCursorLines
              { Fl_Button* o = btnCursorBWcolor = new Fl_Button(15, 172, 20, 20, _("Cursor color"));
                btnCursorBWcolor->tooltip(_("Change color"));
                btnCursorBWcolor->color((Fl_Color)3);
                btnCursorBWcolor->callback((Fl_Callback*)cb_btnCursorBWcolor);
                btnCursorBWcolor->align(FL_ALIGN_RIGHT);
                o->color(fl_rgb_color(progdefaults.cursorLineRGBI.R,progdefaults.cursorLineRGBI.G,progdefaults.cursorLineRGBI.B));
              } // Fl_Button* btnCursorBWcolor
              { Fl_Check_Button* o = btnUseCursorCenterLine = new Fl_Check_Button(185, 149, 149, 20, _("Cursor center line"));
                btnUseCursorCenterLine->tooltip(_("Show cursor with center line"));
                btnUseCursorCenterLine->down_box(FL_DOWN_BOX);
                btnUseCursorCenterLine->callback((Fl_Callback*)cb_btnUseCursorCenterLine);
                o->value(progdefaults.UseCursorCenterLine);
              } // Fl_Check_Button* btnUseCursorCenterLine
              { Fl_Button* o = btnCursorCenterLineColor = new Fl_Button(185, 172, 20, 20, _("Center line color"));
                btnCursorCenterLineColor->tooltip(_("Change color"));
                btnCursorCenterLineColor->color((Fl_Color)FL_BACKGROUND2_COLOR);
                btnCursorCenterLineColor->callback((Fl_Callback*)cb_btnCursorCenterLineColor);
                btnCursorCenterLineColor->align(FL_ALIGN_RIGHT);
                o->color(fl_rgb_color(progdefaults.cursorCenterRGBI.R,progdefaults.cursorCenterRGBI.G,progdefaults.cursorCenterRGBI.B));
              } // Fl_Button* btnCursorCenterLineColor
              { Fl_Check_Button* o = btnUseBWTracks = new Fl_Check_Button(346, 149, 145, 20, _("Bandwidth tracks"));
                btnUseBWTracks->tooltip(_("Show bandwidth tracks on waterfall"));
                btnUseBWTracks->down_box(FL_DOWN_BOX);
                btnUseBWTracks->callback((Fl_Callback*)cb_btnUseBWTracks);
                o->value(progdefaults.UseBWTracks);
              } // Fl_Check_Button* btnUseBWTracks
              { Fl_Button* o = btnBwTracksColor = new Fl_Button(346, 172, 20, 20, _("Tracks color"));
                btnBwTracksColor->tooltip(_("Change color"));
                btnBwTracksColor->color((Fl_Color)1);
                btnBwTracksColor->callback((Fl_Callback*)cb_btnBwTracksColor);
                btnBwTracksColor->align(FL_ALIGN_RIGHT);
                o->color(fl_rgb_color(progdefaults.bwTrackRGBI.R,progdefaults.bwTrackRGBI.G,progdefaults.bwTrackRGBI.B));
              } // Fl_Button* btnBwTracksColor
              { Fl_Check_Button* o = btnUseWideTracks = new Fl_Check_Button(346, 196, 145, 20, _("Wide tracks"));
                btnUseWideTracks->tooltip(_("Show bandwidth tracks on waterfall"));
                btnUseWideTracks->down_box(FL_DOWN_BOX);
                btnUseWideTracks->callback((Fl_Callback*)cb_btnUseWideTracks);
                o->value(progdefaults.UseWideTracks);
              } // Fl_Check_Button* btnUseWideTracks
              { Fl_Check_Button* o = btnUseWideCenter = new Fl_Check_Button(185, 197, 145, 20, _("Wide center line"));
                btnUseWideCenter->tooltip(_("Show bandwidth tracks on waterfall"));
                btnUseWideCenter->down_box(FL_DOWN_BOX);
                btnUseWideCenter->callback((Fl_Callback*)cb_btnUseWideCenter);
                o->value(progdefaults.UseWideCenter);
              } // Fl_Check_Button* btnUseWideCenter
              { Fl_Check_Button* o = btnUseWideCursor = new Fl_Check_Button(15, 195, 145, 20, _("Wide cursor"));
                btnUseWideCursor->tooltip(_("Show bandwidth tracks on waterfall"));
                btnUseWideCursor->down_box(FL_DOWN_BOX);
                btnUseWideCursor->callback((Fl_Callback*)cb_btnUseWideCursor);
                o->value(progdefaults.UseWideCursor);
              } // Fl_Check_Button* btnUseWideCursor
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 222, 490, 62, _("Frequency scale"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chkShowAudioScale = new Fl_Check_Button(15, 252, 240, 20, _("Always show audio frequencies"));
                chkShowAudioScale->tooltip(_("Audio or RF frequencies on waterfall scale"));
                chkShowAudioScale->down_box(FL_DOWN_BOX);
                chkShowAudioScale->callback((Fl_Callback*)cb_chkShowAudioScale);
                o->value(progdefaults.wf_audioscale);
              } // Fl_Check_Button* chkShowAudioScale
              { btnWaterfallFont = new Fl_Button(314, 252, 70, 24, _("Font..."));
                btnWaterfallFont->tooltip(_("Select waterfall scale font"));
                btnWaterfallFont->callback((Fl_Callback*)cb_btnWaterfallFont);
              } // Fl_Button* btnWaterfallFont
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 285, 490, 80, _("Transmit signal"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnViewXmtSignal = new Fl_Check_Button(15, 315, 205, 20, _("Monitor transmitted signal"));
                btnViewXmtSignal->tooltip(_("Show transmit signal on waterfall"));
                btnViewXmtSignal->down_box(FL_DOWN_BOX);
                btnViewXmtSignal->callback((Fl_Callback*)cb_btnViewXmtSignal);
                o->value(progdefaults.viewXmtSignal);
              } // Fl_Check_Button* btnViewXmtSignal
              { Fl_Value_Slider2* o = valTxMonitorLevel = new Fl_Value_Slider2(270, 315, 200, 20, _("Signal level"));
                valTxMonitorLevel->tooltip(_("Set level for good viewing"));
                valTxMonitorLevel->type(1);
                valTxMonitorLevel->box(FL_DOWN_BOX);
                valTxMonitorLevel->color((Fl_Color)FL_BACKGROUND_COLOR);
                valTxMonitorLevel->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                valTxMonitorLevel->labeltype(FL_NORMAL_LABEL);
                valTxMonitorLevel->labelfont(0);
                valTxMonitorLevel->labelsize(14);
                valTxMonitorLevel->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valTxMonitorLevel->step(0.05);
                valTxMonitorLevel->value(0.5);
                valTxMonitorLevel->textsize(14);
                valTxMonitorLevel->callback((Fl_Callback*)cb_valTxMonitorLevel);
                valTxMonitorLevel->align(FL_ALIGN_TOP);
                valTxMonitorLevel->when(FL_WHEN_CHANGED);
                o->value(progdefaults.TxMonitorLevel);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
              } // Fl_Value_Slider2* valTxMonitorLevel
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 500, 320, _("FFT Processing"));
            o->hide();
            { Fl_Group* o = new Fl_Group(5, 62, 490, 135);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Counter2* o = cntLowFreqCutoff = new Fl_Counter2(50, 72, 70, 20, _("Lower limit"));
                cntLowFreqCutoff->tooltip(_("Low frequency limit in Hz"));
                cntLowFreqCutoff->type(1);
                cntLowFreqCutoff->box(FL_UP_BOX);
                cntLowFreqCutoff->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntLowFreqCutoff->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntLowFreqCutoff->labeltype(FL_NORMAL_LABEL);
                cntLowFreqCutoff->labelfont(0);
                cntLowFreqCutoff->labelsize(14);
                cntLowFreqCutoff->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntLowFreqCutoff->minimum(0);
                cntLowFreqCutoff->maximum(500);
                cntLowFreqCutoff->step(50);
                cntLowFreqCutoff->value(300);
                cntLowFreqCutoff->callback((Fl_Callback*)cb_cntLowFreqCutoff);
                cntLowFreqCutoff->align(FL_ALIGN_RIGHT);
                cntLowFreqCutoff->when(FL_WHEN_CHANGED);
                o->value(progdefaults.LowFreqCutoff);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntLowFreqCutoff
              { Fl_Counter2* o = valLatency = new Fl_Counter2(50, 102, 70, 21, _("FFT latency (scan merging)"));
                valLatency->tooltip(_("Latency increases frequency resolution,\ndecreases time resolution. 1 = no sc\
an merging"));
                valLatency->type(1);
                valLatency->box(FL_UP_BOX);
                valLatency->color((Fl_Color)FL_BACKGROUND_COLOR);
                valLatency->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valLatency->labeltype(FL_NORMAL_LABEL);
                valLatency->labelfont(0);
                valLatency->labelsize(14);
                valLatency->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valLatency->minimum(1);
                valLatency->maximum(8);
                valLatency->step(1);
                valLatency->value(4);
                valLatency->callback((Fl_Callback*)cb_valLatency);
                valLatency->align(FL_ALIGN_RIGHT);
                valLatency->when(FL_WHEN_CHANGED);
                o->value(progdefaults.latency);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* valLatency
              { Fl_Check_Button* o = btnWFaveraging = new Fl_Check_Button(50, 133, 120, 20, _("FFT averaging"));
                btnWFaveraging->tooltip(_("Use averaging to decrease waterfall noise"));
                btnWFaveraging->down_box(FL_DOWN_BOX);
                btnWFaveraging->callback((Fl_Callback*)cb_btnWFaveraging);
                o->value(progdefaults.WFaveraging);
              } // Fl_Check_Button* btnWFaveraging
              { mnuFFTPrefilter = new Fl_Choice(50, 163, 120, 25, _("FFT prefilter window function"));
                mnuFFTPrefilter->tooltip(_("Select the type of FFT prefilter"));
                mnuFFTPrefilter->down_box(FL_BORDER_BOX);
                mnuFFTPrefilter->callback((Fl_Callback*)cb_mnuFFTPrefilter);
                mnuFFTPrefilter->align(FL_ALIGN_RIGHT);
                mnuFFTPrefilter->add(_("Rectangular")); mnuFFTPrefilter->add("Blackman");
                mnuFFTPrefilter->add("Hamming"); mnuFFTPrefilter->add("Hanning");
                mnuFFTPrefilter->add(_("Triangular"));
                mnuFFTPrefilter->value(progdefaults.wfPreFilter);
              } // Fl_Choice* mnuFFTPrefilter
              { Fl_Counter2* o = cntrWfwidth = new Fl_Counter2(273, 72, 95, 21, _("Upper limit"));
                cntrWfwidth->tooltip(_("High frequency limit in Hz"));
                cntrWfwidth->type(1);
                cntrWfwidth->box(FL_UP_BOX);
                cntrWfwidth->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntrWfwidth->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntrWfwidth->labeltype(FL_NORMAL_LABEL);
                cntrWfwidth->labelfont(0);
                cntrWfwidth->labelsize(14);
                cntrWfwidth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntrWfwidth->minimum(2000);
                cntrWfwidth->maximum(4000);
                cntrWfwidth->step(100);
                cntrWfwidth->value(3000);
                cntrWfwidth->callback((Fl_Callback*)cb_cntrWfwidth);
                cntrWfwidth->align(FL_ALIGN_RIGHT);
                cntrWfwidth->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HighFreqCutoff);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntrWfwidth
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 212, 490, 80, _("Changes take effect on next program startup"));
              o->tooltip(_("Show me more or less waterfall"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
              { Fl_Counter2* o = cntrWfheight = new Fl_Counter2(50, 242, 95, 21, _("Waterfall height in pixels"));
                cntrWfheight->tooltip(_("CPU usage increases with waterfall height"));
                cntrWfheight->type(1);
                cntrWfheight->box(FL_UP_BOX);
                cntrWfheight->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntrWfheight->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntrWfheight->labeltype(FL_NORMAL_LABEL);
                cntrWfheight->labelfont(0);
                cntrWfheight->labelsize(14);
                cntrWfheight->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntrWfheight->minimum(100);
                cntrWfheight->maximum(160);
                cntrWfheight->step(5);
                cntrWfheight->value(120);
                cntrWfheight->callback((Fl_Callback*)cb_cntrWfheight);
                cntrWfheight->align(FL_ALIGN_RIGHT);
                cntrWfheight->when(FL_WHEN_CHANGED);
                o->value(progdefaults.wfheight);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntrWfheight
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 500, 320, _("Mouse"));
            o->hide();
            { Fl_Group* o = new Fl_Group(5, 62, 490, 170);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnWaterfallHistoryDefault = new Fl_Check_Button(15, 76, 340, 20, _("Left or right click always replays audio history"));
                btnWaterfallHistoryDefault->tooltip(_("Replay trackline audio"));
                btnWaterfallHistoryDefault->down_box(FL_DOWN_BOX);
                btnWaterfallHistoryDefault->callback((Fl_Callback*)cb_btnWaterfallHistoryDefault);
                o->value(progdefaults.WaterfallHistoryDefault);
              } // Fl_Check_Button* btnWaterfallHistoryDefault
              { Fl_Check_Button* o = btnWaterfallQSY = new Fl_Check_Button(15, 106, 380, 20, _("Dragging on the waterfall scale changes frequency"));
                btnWaterfallQSY->tooltip(_("Enable drag cursor on waterfall scale"));
                btnWaterfallQSY->down_box(FL_DOWN_BOX);
                btnWaterfallQSY->callback((Fl_Callback*)cb_btnWaterfallQSY);
                o->value(progdefaults.WaterfallQSY);
              } // Fl_Check_Button* btnWaterfallQSY
              { Fl_Check_Button* o = btnWaterfallClickInsert = new Fl_Check_Button(15, 148, 225, 20, _("Insert text on single left click"));
                btnWaterfallClickInsert->tooltip(_("Insert special text in Rx panel\nwhen waterfall clicked"));
                btnWaterfallClickInsert->down_box(FL_DOWN_BOX);
                btnWaterfallClickInsert->callback((Fl_Callback*)cb_btnWaterfallClickInsert);
                o->value(progdefaults.WaterfallClickInsert);
              } // Fl_Check_Button* btnWaterfallClickInsert
              { inpWaterfallClickText = new Fl_Input2(301, 136, 180, 50);
                inpWaterfallClickText->tooltip(_("The string <FREQ> is replaced with\nthe current modem and frequency"));
                inpWaterfallClickText->box(FL_DOWN_BOX);
                inpWaterfallClickText->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpWaterfallClickText->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpWaterfallClickText->labeltype(FL_NORMAL_LABEL);
                inpWaterfallClickText->labelfont(0);
                inpWaterfallClickText->labelsize(14);
                inpWaterfallClickText->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpWaterfallClickText->callback((Fl_Callback*)cb_inpWaterfallClickText);
                inpWaterfallClickText->align(FL_ALIGN_RIGHT);
                inpWaterfallClickText->when(FL_WHEN_RELEASE);
              } // Fl_Input2* inpWaterfallClickText
              o->end();
            } // Fl_Group* o
            { mnuWaterfallWheelAction = new Fl_Choice(15, 196, 150, 22, _("Wheel action"));
              mnuWaterfallWheelAction->tooltip(_("Select how the mouse wheel\nbehaves inside the waterfall"));
              mnuWaterfallWheelAction->down_box(FL_BORDER_BOX);
              mnuWaterfallWheelAction->callback((Fl_Callback*)cb_mnuWaterfallWheelAction);
              mnuWaterfallWheelAction->align(FL_ALIGN_RIGHT);
            } // Fl_Choice* mnuWaterfallWheelAction
            o->end();
          } // Fl_Group* o
          tabsWaterfall->end();
        } // Fl_Tabs* tabsWaterfall
        tabWaterfall->end();
      } // Fl_Group* tabWaterfall
      { tabModems = new Fl_Group(-4, 25, 521, 347, _("Modems"));
        { tabsModems = new Fl_Tabs(-4, 25, 521, 347);
          tabsModems->selection_color((Fl_Color)FL_LIGHT1);
          tabsModems->align(FL_ALIGN_TOP_RIGHT);
          { tabCW = new Fl_Group(0, 50, 504, 320, _("CW"));
            tabCW->hide();
            { tabsCW = new Fl_Tabs(0, 50, 504, 320);
              tabsCW->selection_color((Fl_Color)FL_LIGHT1);
              { Fl_Group* o = new Fl_Group(0, 75, 500, 295, _("General"));
                o->align(FL_ALIGN_TOP_LEFT);
                { Fl_Group* o = new Fl_Group(5, 85, 490, 130, _("Receive"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Value_Slider2* o = sldrCWbandwidth = new Fl_Value_Slider2(40, 115, 290, 20, _("Filter bandwidth"));
                sldrCWbandwidth->tooltip(_("CW dsp filter bandwidth"));
                sldrCWbandwidth->type(1);
                sldrCWbandwidth->box(FL_DOWN_BOX);
                sldrCWbandwidth->color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrCWbandwidth->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrCWbandwidth->labeltype(FL_NORMAL_LABEL);
                sldrCWbandwidth->labelfont(0);
                sldrCWbandwidth->labelsize(14);
                sldrCWbandwidth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                sldrCWbandwidth->minimum(10);
                sldrCWbandwidth->maximum(500);
                sldrCWbandwidth->step(10);
                sldrCWbandwidth->value(150);
                sldrCWbandwidth->textsize(14);
                sldrCWbandwidth->callback((Fl_Callback*)cb_sldrCWbandwidth);
                sldrCWbandwidth->align(FL_ALIGN_RIGHT);
                sldrCWbandwidth->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWbandwidth);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
                } // Fl_Value_Slider2* sldrCWbandwidth
                { Fl_Check_Button* o = btnCWrcvTrack = new Fl_Check_Button(40, 150, 80, 20, _("Tracking"));
                btnCWrcvTrack->tooltip(_("Automatic Rx speed tracking"));
                btnCWrcvTrack->down_box(FL_DOWN_BOX);
                btnCWrcvTrack->value(1);
                btnCWrcvTrack->callback((Fl_Callback*)cb_btnCWrcvTrack);
                o->value(progdefaults.CWtrack);
                } // Fl_Check_Button* btnCWrcvTrack
                { Fl_Counter2* o = cntCWrange = new Fl_Counter2(225, 150, 65, 20, _("Tracking range (WPM)"));
                cntCWrange->tooltip(_("Range +/- wpm"));
                cntCWrange->type(1);
                cntCWrange->box(FL_UP_BOX);
                cntCWrange->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntCWrange->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntCWrange->labeltype(FL_NORMAL_LABEL);
                cntCWrange->labelfont(0);
                cntCWrange->labelsize(14);
                cntCWrange->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntCWrange->minimum(5);
                cntCWrange->maximum(25);
                cntCWrange->step(1);
                cntCWrange->value(10);
                cntCWrange->callback((Fl_Callback*)cb_cntCWrange);
                cntCWrange->align(FL_ALIGN_RIGHT);
                cntCWrange->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWrange);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntCWrange
                { valCWrcvWPM = new Fl_Value_Output(70, 185, 35, 20);
                valCWrcvWPM->color((Fl_Color)FL_BACKGROUND2_COLOR);
                valCWrcvWPM->callback((Fl_Callback*)cb_valCWrcvWPM);
                } // Fl_Value_Output* valCWrcvWPM
                { prgsCWrcvWPM = new Fl_Progress(105, 185, 250, 20);
                prgsCWrcvWPM->tooltip(_("Tracked CW speed in WPM"));
                prgsCWrcvWPM->color((Fl_Color)FL_BACKGROUND_COLOR);
                prgsCWrcvWPM->selection_color((Fl_Color)FL_SELECTION_COLOR);
                prgsCWrcvWPM->align(FL_ALIGN_CENTER);
                } // Fl_Progress* prgsCWrcvWPM
                { Fl_Box* o = new Fl_Box(360, 185, 70, 20, _("RX WPM"));
                o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(5, 215, 490, 150, _("Transmit"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Value_Slider2* o = sldrCWxmtWPM = new Fl_Value_Slider2(20, 240, 400, 20, _("TX WPM"));
                sldrCWxmtWPM->tooltip(_("My transmit CW WPM"));
                sldrCWxmtWPM->type(1);
                sldrCWxmtWPM->box(FL_DOWN_BOX);
                sldrCWxmtWPM->color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrCWxmtWPM->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrCWxmtWPM->labeltype(FL_NORMAL_LABEL);
                sldrCWxmtWPM->labelfont(0);
                sldrCWxmtWPM->labelsize(14);
                sldrCWxmtWPM->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                sldrCWxmtWPM->minimum(5);
                sldrCWxmtWPM->maximum(100);
                sldrCWxmtWPM->step(1);
                sldrCWxmtWPM->value(20);
                sldrCWxmtWPM->textsize(14);
                sldrCWxmtWPM->callback((Fl_Callback*)cb_sldrCWxmtWPM);
                sldrCWxmtWPM->align(FL_ALIGN_RIGHT);
                sldrCWxmtWPM->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWspeed);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
                } // Fl_Value_Slider2* sldrCWxmtWPM
                { Fl_Counter2* o = cntCWdefWPM = new Fl_Counter2(40, 281, 64, 20, _("Default"));
                cntCWdefWPM->tooltip(_("The default CW speed"));
                cntCWdefWPM->type(1);
                cntCWdefWPM->box(FL_UP_BOX);
                cntCWdefWPM->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntCWdefWPM->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntCWdefWPM->labeltype(FL_NORMAL_LABEL);
                cntCWdefWPM->labelfont(0);
                cntCWdefWPM->labelsize(14);
                cntCWdefWPM->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntCWdefWPM->minimum(5);
                cntCWdefWPM->maximum(200);
                cntCWdefWPM->step(1);
                cntCWdefWPM->value(18);
                cntCWdefWPM->callback((Fl_Callback*)cb_cntCWdefWPM);
                cntCWdefWPM->align(FL_ALIGN_TOP);
                cntCWdefWPM->when(FL_WHEN_CHANGED);
                o->value(progdefaults.defCWspeed);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntCWdefWPM
                { Fl_Counter* o = cntCWlowerlimit = new Fl_Counter(197, 281, 65, 20, _("Lower limit"));
                cntCWlowerlimit->tooltip(_("No slower than this"));
                cntCWlowerlimit->type(1);
                cntCWlowerlimit->minimum(5);
                cntCWlowerlimit->maximum(20);
                cntCWlowerlimit->step(5);
                cntCWlowerlimit->value(10);
                cntCWlowerlimit->callback((Fl_Callback*)cb_cntCWlowerlimit);
                cntCWlowerlimit->align(FL_ALIGN_TOP);
                o->value(progdefaults.CWlowerlimit);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter* cntCWlowerlimit
                { Fl_Counter* o = cntCWupperlimit = new Fl_Counter(355, 281, 65, 20, _("Upper limit"));
                cntCWupperlimit->tooltip(_("No faster than this"));
                cntCWupperlimit->type(1);
                cntCWupperlimit->minimum(25);
                cntCWupperlimit->maximum(200);
                cntCWupperlimit->step(5);
                cntCWupperlimit->value(100);
                cntCWupperlimit->callback((Fl_Callback*)cb_cntCWupperlimit);
                cntCWupperlimit->align(FL_ALIGN_TOP);
                o->value(progdefaults.CWupperlimit);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter* cntCWupperlimit
                { Fl_Value_Slider2* o = sldrCWfarnsworth = new Fl_Value_Slider2(20, 335, 400, 20, _("F-WPM"));
                sldrCWfarnsworth->tooltip(_("My transmit CW WPM"));
                sldrCWfarnsworth->type(1);
                sldrCWfarnsworth->box(FL_DOWN_BOX);
                sldrCWfarnsworth->color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrCWfarnsworth->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrCWfarnsworth->labeltype(FL_NORMAL_LABEL);
                sldrCWfarnsworth->labelfont(0);
                sldrCWfarnsworth->labelsize(14);
                sldrCWfarnsworth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                sldrCWfarnsworth->minimum(5);
                sldrCWfarnsworth->maximum(100);
                sldrCWfarnsworth->step(1);
                sldrCWfarnsworth->value(20);
                sldrCWfarnsworth->textsize(14);
                sldrCWfarnsworth->callback((Fl_Callback*)cb_sldrCWfarnsworth);
                sldrCWfarnsworth->align(FL_ALIGN_RIGHT);
                sldrCWfarnsworth->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWfarnsworth);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
                } // Fl_Value_Slider2* sldrCWfarnsworth
                { Fl_Check_Button* o = btnCWusefarnsworth = new Fl_Check_Button(40, 312, 180, 15, _("Use Farnsworth timing"));
                btnCWusefarnsworth->down_box(FL_DOWN_BOX);
                btnCWusefarnsworth->callback((Fl_Callback*)cb_btnCWusefarnsworth);
                o->value(progdefaults.CWusefarnsworth);
                } // Fl_Check_Button* btnCWusefarnsworth
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(0, 75, 500, 295, _("Timing and QSK"));
                o->align(FL_ALIGN_TOP_LEFT);
                o->hide();
                { Fl_Group* o = new Fl_Group(5, 85, 490, 120, _("Timing"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Counter2* o = cntCWweight = new Fl_Counter2(15, 114, 65, 20, _("Weight (%)"));
                cntCWweight->tooltip(_("Dot to dot-space ratio"));
                cntCWweight->type(1);
                cntCWweight->box(FL_UP_BOX);
                cntCWweight->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntCWweight->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntCWweight->labeltype(FL_NORMAL_LABEL);
                cntCWweight->labelfont(0);
                cntCWweight->labelsize(14);
                cntCWweight->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntCWweight->minimum(20);
                cntCWweight->maximum(80);
                cntCWweight->step(1);
                cntCWweight->value(50);
                cntCWweight->callback((Fl_Callback*)cb_cntCWweight);
                cntCWweight->align(FL_ALIGN_RIGHT);
                cntCWweight->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWweight);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntCWweight
                { Fl_Counter2* o = cntCWdash2dot = new Fl_Counter2(240, 114, 64, 20, _("Dash to dot ratio"));
                cntCWdash2dot->tooltip(_("Dash to dot ratio"));
                cntCWdash2dot->type(1);
                cntCWdash2dot->box(FL_UP_BOX);
                cntCWdash2dot->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntCWdash2dot->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntCWdash2dot->labeltype(FL_NORMAL_LABEL);
                cntCWdash2dot->labelfont(0);
                cntCWdash2dot->labelsize(14);
                cntCWdash2dot->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntCWdash2dot->minimum(2.5);
                cntCWdash2dot->maximum(4);
                cntCWdash2dot->value(3);
                cntCWdash2dot->callback((Fl_Callback*)cb_cntCWdash2dot);
                cntCWdash2dot->align(FL_ALIGN_RIGHT);
                cntCWdash2dot->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWdash2dot);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntCWdash2dot
                { Fl_Counter2* o = cntCWrisetime = new Fl_Counter2(240, 145, 65, 20, _("Edge timing"));
                cntCWrisetime->tooltip(_("Leading and Trailing edge risetimes (msec)"));
                cntCWrisetime->type(1);
                cntCWrisetime->box(FL_UP_BOX);
                cntCWrisetime->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntCWrisetime->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntCWrisetime->labeltype(FL_NORMAL_LABEL);
                cntCWrisetime->labelfont(0);
                cntCWrisetime->labelsize(14);
                cntCWrisetime->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntCWrisetime->minimum(0);
                cntCWrisetime->maximum(15);
                cntCWrisetime->value(4);
                cntCWrisetime->callback((Fl_Callback*)cb_cntCWrisetime);
                cntCWrisetime->align(FL_ALIGN_RIGHT);
                cntCWrisetime->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWrisetime);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntCWrisetime
                { Fl_Choice* o = mnuQSKshape = new Fl_Choice(15, 144, 112, 20, _("Edge shape"));
                mnuQSKshape->tooltip(_("Raised cosine = Hanning"));
                mnuQSKshape->down_box(FL_BORDER_BOX);
                mnuQSKshape->callback((Fl_Callback*)cb_mnuQSKshape);
                mnuQSKshape->align(FL_ALIGN_RIGHT);
                o->add("Hanning|Blackman");
                o->value(progdefaults.QSKshape);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Choice* mnuQSKshape
                { Fl_Check_Button* o = btnCWnarrow = new Fl_Check_Button(15, 175, 225, 15, _("Edge decreases pulse width"));
                btnCWnarrow->tooltip(_("Weight decreases with increasing edge timing"));
                btnCWnarrow->down_box(FL_DOWN_BOX);
                btnCWnarrow->callback((Fl_Callback*)cb_btnCWnarrow);
                o->value(progdefaults.CWnarrow);
                } // Fl_Check_Button* btnCWnarrow
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(5, 217, 490, 118, _("QSK"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Check_Button* o = btnQSK = new Fl_Check_Button(15, 245, 211, 20, _("QSK on right audio channel"));
                btnQSK->tooltip(_("Generate square wave signal on right channel"));
                btnQSK->down_box(FL_DOWN_BOX);
                btnQSK->callback((Fl_Callback*)cb_btnQSK);
                o->value(progdefaults.QSK);
                } // Fl_Check_Button* btnQSK
                { Fl_Counter2* o = cntPreTiming = new Fl_Counter2(15, 275, 64, 20, _("Pre-keydown timing (ms)"));
                cntPreTiming->tooltip(_("Msec pre-keydown (+ is earlier in time)"));
                cntPreTiming->type(1);
                cntPreTiming->box(FL_UP_BOX);
                cntPreTiming->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntPreTiming->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntPreTiming->labeltype(FL_NORMAL_LABEL);
                cntPreTiming->labelfont(0);
                cntPreTiming->labelsize(14);
                cntPreTiming->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntPreTiming->minimum(0);
                cntPreTiming->maximum(20);
                cntPreTiming->step(0.5);
                cntPreTiming->callback((Fl_Callback*)cb_cntPreTiming);
                cntPreTiming->align(FL_ALIGN_RIGHT);
                cntPreTiming->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWpre);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntPreTiming
                { Fl_Counter2* o = cntPostTiming = new Fl_Counter2(15, 305, 64, 20, _("Post-keydown timing (ms)"));
                cntPostTiming->tooltip(_("Msec post-keydown (+ is earlier in time)"));
                cntPostTiming->type(1);
                cntPostTiming->box(FL_UP_BOX);
                cntPostTiming->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntPostTiming->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntPostTiming->labeltype(FL_NORMAL_LABEL);
                cntPostTiming->labelfont(0);
                cntPostTiming->labelsize(14);
                cntPostTiming->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntPostTiming->minimum(-20);
                cntPostTiming->maximum(20);
                cntPostTiming->step(0.5);
                cntPostTiming->callback((Fl_Callback*)cb_cntPostTiming);
                cntPostTiming->align(FL_ALIGN_RIGHT);
                cntPostTiming->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWpre);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntPostTiming
                { Fl_Check_Button* o = btnQSKadjust = new Fl_Check_Button(290, 275, 160, 20, _("Send continuously"));
                btnQSKadjust->tooltip(_("Send a continuous stream of test characters"));
                btnQSKadjust->down_box(FL_DOWN_BOX);
                btnQSKadjust->callback((Fl_Callback*)cb_btnQSKadjust);
                o->value(progdefaults.QSKadjust);
                } // Fl_Check_Button* btnQSKadjust
                { Fl_Choice* o = mnuTestChar = new Fl_Choice(290, 245, 41, 20, _("Test char"));
                mnuTestChar->tooltip(_("Test character for QSK adjustment"));
                mnuTestChar->down_box(FL_BORDER_BOX);
                mnuTestChar->callback((Fl_Callback*)cb_mnuTestChar);
                mnuTestChar->align(FL_ALIGN_RIGHT);
                o->add(szTestChar);
                o->value(progdefaults.TestChar);
                } // Fl_Choice* mnuTestChar
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(0, 75, 500, 295, _("Prosigns"));
                o->align(FL_ALIGN_TOP_LEFT);
                o->hide();
                { Fl_Group* o = new Fl_Group(4, 81, 492, 283);
                o->box(FL_ENGRAVED_FRAME);
                { Fl_Check_Button* o = btnCW_use_paren = new Fl_Check_Button(235, 236, 68, 15, _("Use \'(\' paren not KN"));
                btnCW_use_paren->down_box(FL_DOWN_BOX);
                btnCW_use_paren->callback((Fl_Callback*)cb_btnCW_use_paren);
                o->value(progdefaults.CW_use_paren);
                } // Fl_Check_Button* btnCW_use_paren
                o->end();
                } // Fl_Group* o
                { Fl_Choice* o = mnu_prosign[0] = new Fl_Choice(167, 94, 47, 22, _("<BT>"));
                mnu_prosign[0]->down_box(FL_BORDER_BOX);
                mnu_prosign[0]->callback((Fl_Callback*)cb_mnu_prosign);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[0];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[0]
                { Fl_Choice* o = mnu_prosign[1] = new Fl_Choice(167, 121, 47, 22, _("<AA>"));
                mnu_prosign[1]->down_box(FL_BORDER_BOX);
                mnu_prosign[1]->callback((Fl_Callback*)cb_mnu_prosign1);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[1];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[1]
                { Fl_Choice* o = mnu_prosign[2] = new Fl_Choice(167, 149, 47, 22, _("<AS>"));
                mnu_prosign[2]->down_box(FL_BORDER_BOX);
                mnu_prosign[2]->callback((Fl_Callback*)cb_mnu_prosign2);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[2];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[2]
                { Fl_Choice* o = mnu_prosign[3] = new Fl_Choice(167, 176, 47, 22, _("<AR>"));
                mnu_prosign[3]->down_box(FL_BORDER_BOX);
                mnu_prosign[3]->callback((Fl_Callback*)cb_mnu_prosign3);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[3];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[3]
                { Fl_Choice* o = mnu_prosign[4] = new Fl_Choice(167, 204, 47, 22, _("<SK>"));
                mnu_prosign[4]->down_box(FL_BORDER_BOX);
                mnu_prosign[4]->callback((Fl_Callback*)cb_mnu_prosign4);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[4];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[4]
                { Fl_Choice* o = mnu_prosign[5] = new Fl_Choice(167, 232, 47, 22, _("<KN>"));
                mnu_prosign[5]->down_box(FL_BORDER_BOX);
                mnu_prosign[5]->callback((Fl_Callback*)cb_mnu_prosign5);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[5];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[5]
                { Fl_Choice* o = mnu_prosign[6] = new Fl_Choice(167, 259, 47, 22, _("<INT>"));
                mnu_prosign[6]->down_box(FL_BORDER_BOX);
                mnu_prosign[6]->callback((Fl_Callback*)cb_mnu_prosign6);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[6];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[6]
                { Fl_Choice* o = mnu_prosign[7] = new Fl_Choice(167, 287, 47, 22, _("<HM>"));
                mnu_prosign[7]->down_box(FL_BORDER_BOX);
                mnu_prosign[7]->callback((Fl_Callback*)cb_mnu_prosign7);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[7];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[7]
                { Fl_Choice* o = mnu_prosign[8] = new Fl_Choice(167, 315, 47, 22, _("<VE>"));
                mnu_prosign[8]->down_box(FL_BORDER_BOX);
                mnu_prosign[8]->callback((Fl_Callback*)cb_mnu_prosign8);
                o->add(szProsigns);
                char s[2] = " "; s[0] = progdefaults.CW_prosigns[8];
                o->value(o->find_item(s));
                } // Fl_Choice* mnu_prosign[8]
                o->end();
              } // Fl_Group* o
              tabsCW->end();
            } // Fl_Tabs* tabsCW
            tabCW->end();
          } // Fl_Group* tabCW
          { tabDomEX = new Fl_Group(0, 50, 500, 320, _("DomEX"));
            tabDomEX->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 180);
              o->box(FL_ENGRAVED_FRAME);
              { txtSecondary = new Fl_Input2(15, 87, 360, 40, _("Secondary Text"));
                txtSecondary->tooltip(_("Text to send during keyboard idle times"));
                txtSecondary->type(4);
                txtSecondary->box(FL_DOWN_BOX);
                txtSecondary->color((Fl_Color)FL_BACKGROUND2_COLOR);
                txtSecondary->selection_color((Fl_Color)FL_SELECTION_COLOR);
                txtSecondary->labeltype(FL_NORMAL_LABEL);
                txtSecondary->labelfont(0);
                txtSecondary->labelsize(14);
                txtSecondary->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                txtSecondary->callback((Fl_Callback*)cb_txtSecondary);
                txtSecondary->align(FL_ALIGN_TOP_LEFT);
                txtSecondary->when(FL_WHEN_CHANGED);
                txtSecondary->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* txtSecondary
              { Fl_Check_Button* o = valDominoEX_FILTER = new Fl_Check_Button(15, 141, 80, 20, _("Filtering"));
                valDominoEX_FILTER->tooltip(_("Use DSP filter before decoder"));
                valDominoEX_FILTER->down_box(FL_DOWN_BOX);
                valDominoEX_FILTER->value(1);
                valDominoEX_FILTER->callback((Fl_Callback*)cb_valDominoEX_FILTER);
                o->value(progdefaults.DOMINOEX_FILTER);
              } // Fl_Check_Button* valDominoEX_FILTER
              { Fl_Counter2* o = valDominoEX_BW = new Fl_Counter2(156, 141, 63, 20, _("Filter bandwidth factor"));
                valDominoEX_BW->tooltip(_("Filter bandwidth relative to signal width"));
                valDominoEX_BW->type(1);
                valDominoEX_BW->box(FL_UP_BOX);
                valDominoEX_BW->color((Fl_Color)FL_BACKGROUND_COLOR);
                valDominoEX_BW->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valDominoEX_BW->labeltype(FL_NORMAL_LABEL);
                valDominoEX_BW->labelfont(0);
                valDominoEX_BW->labelsize(14);
                valDominoEX_BW->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valDominoEX_BW->minimum(1);
                valDominoEX_BW->maximum(2);
                valDominoEX_BW->value(1.5);
                valDominoEX_BW->callback((Fl_Callback*)cb_valDominoEX_BW);
                valDominoEX_BW->align(FL_ALIGN_RIGHT);
                valDominoEX_BW->when(FL_WHEN_CHANGED);
                o->value(progdefaults.DOMINOEX_BW);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* valDominoEX_BW
              { Fl_Check_Button* o = chkDominoEX_FEC = new Fl_Check_Button(15, 171, 51, 20, _("FEC"));
                chkDominoEX_FEC->tooltip(_("Enable MultiPSK-compatible FEC"));
                chkDominoEX_FEC->down_box(FL_DOWN_BOX);
                chkDominoEX_FEC->callback((Fl_Callback*)cb_chkDominoEX_FEC);
                o->value(progdefaults.DOMINOEX_FEC);
              } // Fl_Check_Button* chkDominoEX_FEC
              { Fl_Value_Slider2* o = valDomCWI = new Fl_Value_Slider2(15, 207, 260, 20, _("CWI threshold"));
                valDomCWI->tooltip(_("CWI detection and suppression"));
                valDomCWI->type(1);
                valDomCWI->box(FL_DOWN_BOX);
                valDomCWI->color((Fl_Color)FL_BACKGROUND_COLOR);
                valDomCWI->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                valDomCWI->labeltype(FL_NORMAL_LABEL);
                valDomCWI->labelfont(0);
                valDomCWI->labelsize(14);
                valDomCWI->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valDomCWI->textsize(14);
                valDomCWI->callback((Fl_Callback*)cb_valDomCWI);
                valDomCWI->align(FL_ALIGN_TOP);
                valDomCWI->when(FL_WHEN_CHANGED);
                o->value(progdefaults.DomCWI);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
              } // Fl_Value_Slider2* valDomCWI
              { Fl_Counter2* o = valDominoEX_PATHS = new Fl_Counter2(339, 194, 63, 20, _("Paths (hidden)"));
                valDominoEX_PATHS->type(1);
                valDominoEX_PATHS->box(FL_UP_BOX);
                valDominoEX_PATHS->color((Fl_Color)FL_BACKGROUND_COLOR);
                valDominoEX_PATHS->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valDominoEX_PATHS->labeltype(FL_NORMAL_LABEL);
                valDominoEX_PATHS->labelfont(0);
                valDominoEX_PATHS->labelsize(14);
                valDominoEX_PATHS->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valDominoEX_PATHS->minimum(4);
                valDominoEX_PATHS->maximum(8);
                valDominoEX_PATHS->step(1);
                valDominoEX_PATHS->value(5);
                valDominoEX_PATHS->callback((Fl_Callback*)cb_valDominoEX_PATHS);
                valDominoEX_PATHS->align(FL_ALIGN_BOTTOM);
                valDominoEX_PATHS->when(FL_WHEN_CHANGED);
                o->value(progdefaults.DOMINOEX_PATHS);
                o->labelsize(FL_NORMAL_SIZE);
                o->hide();
              } // Fl_Counter2* valDominoEX_PATHS
              o->end();
            } // Fl_Group* o
            tabDomEX->end();
          } // Fl_Group* tabDomEX
          { tabFeld = new Fl_Group(0, 50, 500, 320, _("Feldhell"));
            tabFeld->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 145);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Choice* o = selHellFont = new Fl_Choice(15, 70, 150, 20, _("Transmit font"));
                selHellFont->tooltip(_("Select TX raster font"));
                selHellFont->down_box(FL_BORDER_BOX);
                selHellFont->callback((Fl_Callback*)cb_selHellFont);
                selHellFont->align(FL_ALIGN_RIGHT);
                o->add(szFeldFonts);
                o->value(progdefaults.feldfontnbr);
              } // Fl_Choice* selHellFont
              { Fl_Check_Button* o = btnBlackboard = new Fl_Check_Button(300, 70, 125, 20, _("Reverse video"));
                btnBlackboard->tooltip(_("Display RX in reverse video"));
                btnBlackboard->down_box(FL_DOWN_BOX);
                btnBlackboard->callback((Fl_Callback*)cb_btnBlackboard);
                o->value(progdefaults.HellBlackboard);
              } // Fl_Check_Button* btnBlackboard
              { Fl_Spinner2* o = valHellXmtWidth = new Fl_Spinner2(15, 100, 40, 20, _("Transmit width"));
                valHellXmtWidth->tooltip(_("# of multiple scans / character line"));
                valHellXmtWidth->box(FL_NO_BOX);
                valHellXmtWidth->color((Fl_Color)FL_BACKGROUND_COLOR);
                valHellXmtWidth->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                valHellXmtWidth->labeltype(FL_NORMAL_LABEL);
                valHellXmtWidth->labelfont(0);
                valHellXmtWidth->labelsize(14);
                valHellXmtWidth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valHellXmtWidth->maximum(3);
                valHellXmtWidth->callback((Fl_Callback*)cb_valHellXmtWidth);
                valHellXmtWidth->align(FL_ALIGN_RIGHT);
                valHellXmtWidth->when(FL_WHEN_RELEASE);
                o->value(progdefaults.HellXmtWidth);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* valHellXmtWidth
              { Fl_Check_Button* o = btnHellRcvWidth = new Fl_Check_Button(300, 100, 155, 20, _("Halve receive width"));
                btnHellRcvWidth->tooltip(_("Compress Rx in time"));
                btnHellRcvWidth->down_box(FL_DOWN_BOX);
                btnHellRcvWidth->callback((Fl_Callback*)cb_btnHellRcvWidth);
                o->value(progdefaults.HellRcvWidth);
              } // Fl_Check_Button* btnHellRcvWidth
              { Fl_Choice* o = mnuHellPulse = new Fl_Choice(15, 147, 150, 20, _("Pulse shape"));
                mnuHellPulse->tooltip(_("Raised cosine pulse shape factor"));
                mnuHellPulse->down_box(FL_BORDER_BOX);
                mnuHellPulse->callback((Fl_Callback*)cb_mnuHellPulse);
                mnuHellPulse->align(FL_ALIGN_TOP_LEFT);
                o->add(_("Slow (4 msec)"));
                o->add(_("Fast (2 msec)"));
                o->value(progdefaults.HellPulseFast);
              } // Fl_Choice* mnuHellPulse
              { Fl_Value_Slider2* o = sldrHellBW = new Fl_Value_Slider2(206, 147, 246, 20, _("Receive filter bandwidth"));
                sldrHellBW->tooltip(_("Adjust the DSP bandwidth"));
                sldrHellBW->type(1);
                sldrHellBW->box(FL_DOWN_BOX);
                sldrHellBW->color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrHellBW->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrHellBW->labeltype(FL_NORMAL_LABEL);
                sldrHellBW->labelfont(0);
                sldrHellBW->labelsize(14);
                sldrHellBW->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                sldrHellBW->minimum(10);
                sldrHellBW->maximum(2400);
                sldrHellBW->step(5);
                sldrHellBW->value(400);
                sldrHellBW->textsize(14);
                sldrHellBW->callback((Fl_Callback*)cb_sldrHellBW);
                sldrHellBW->align(FL_ALIGN_TOP_LEFT);
                sldrHellBW->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HELL_BW);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
              } // Fl_Value_Slider2* sldrHellBW
              { Fl_Check_Button* o = btnFeldHellIdle = new Fl_Check_Button(15, 177, 230, 20, _("Transmit periods (.) when idle"));
                btnFeldHellIdle->tooltip(_("Transmits a diddle dot when no keyboard activity"));
                btnFeldHellIdle->down_box(FL_DOWN_BOX);
                btnFeldHellIdle->value(1);
                btnFeldHellIdle->callback((Fl_Callback*)cb_btnFeldHellIdle);
                o->value(progdefaults.HellXmtIdle);
              } // Fl_Check_Button* btnFeldHellIdle
              { Fl_Check_Button* o = btnHellXmtWidth = new Fl_Check_Button(305, 175, 113, 20, _("2x Xmt Width (hidden)"));
                btnHellXmtWidth->down_box(FL_DOWN_BOX);
                btnHellXmtWidth->callback((Fl_Callback*)cb_btnHellXmtWidth);
                o->value(progdefaults.HellXmtWidth);
                o->hide();
              } // Fl_Check_Button* btnHellXmtWidth
              o->end();
            } // Fl_Group* o
            tabFeld->end();
          } // Fl_Group* tabFeld
          { tabMT63 = new Fl_Group(0, 50, 500, 320, _("MT-63"));
            tabMT63->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 115);
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnmt63_interleave = new Fl_Check_Button(150, 78, 185, 20, _("64-bit (long) interleave"));
                btnmt63_interleave->down_box(FL_DOWN_BOX);
                btnmt63_interleave->value(1);
                btnmt63_interleave->callback((Fl_Callback*)cb_btnmt63_interleave);
                o->value(0);if (progdefaults.mt63_interleave == 64) o->value(1);
              } // Fl_Check_Button* btnmt63_interleave
              { Fl_Check_Button* o = btnMT63_8bit = new Fl_Check_Button(150, 108, 205, 20, _("8-bit extended characters"));
                btnMT63_8bit->tooltip(_("Enable this for Latin-1 accented characters"));
                btnMT63_8bit->down_box(FL_DOWN_BOX);
                btnMT63_8bit->callback((Fl_Callback*)cb_btnMT63_8bit);
                o->value(progdefaults.mt63_8bit);
              } // Fl_Check_Button* btnMT63_8bit
              { Fl_Check_Button* o = btnMT63_rx_integration = new Fl_Check_Button(150, 138, 190, 20, _("Long receive integration"));
                btnMT63_rx_integration->tooltip(_("Enable for very weak signals"));
                btnMT63_rx_integration->down_box(FL_DOWN_BOX);
                btnMT63_rx_integration->callback((Fl_Callback*)cb_btnMT63_rx_integration);
                o->value(progdefaults.mt63_rx_integration);
              } // Fl_Check_Button* btnMT63_rx_integration
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(6, 176, 490, 131);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnMT63_usetones = new Fl_Check_Button(150, 184, 200, 20, _("Transmit lower start tone"));
                btnMT63_usetones->down_box(FL_DOWN_BOX);
                btnMT63_usetones->callback((Fl_Callback*)cb_btnMT63_usetones);
                o->value(progdefaults.mt63_usetones);
              } // Fl_Check_Button* btnMT63_usetones
              { Fl_Check_Button* o = btnMT63_upper_lower = new Fl_Check_Button(150, 214, 200, 20, _("Transmit upper start tone"));
                btnMT63_upper_lower->down_box(FL_DOWN_BOX);
                btnMT63_upper_lower->callback((Fl_Callback*)cb_btnMT63_upper_lower);
                o->value(progdefaults.mt63_twotones);
                if (!btnMT63_usetones->value()) o->deactivate();
              } // Fl_Check_Button* btnMT63_upper_lower
              { Fl_Spinner2* o = MT63_tone_duration = new Fl_Spinner2(150, 240, 40, 20, _("Tone Duration (secs)"));
                MT63_tone_duration->box(FL_NO_BOX);
                MT63_tone_duration->color((Fl_Color)FL_BACKGROUND_COLOR);
                MT63_tone_duration->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                MT63_tone_duration->labeltype(FL_NORMAL_LABEL);
                MT63_tone_duration->labelfont(0);
                MT63_tone_duration->labelsize(14);
                MT63_tone_duration->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                MT63_tone_duration->maximum(10);
                MT63_tone_duration->value(4);
                MT63_tone_duration->callback((Fl_Callback*)cb_MT63_tone_duration);
                MT63_tone_duration->align(FL_ALIGN_RIGHT);
                MT63_tone_duration->when(FL_WHEN_RELEASE);
                o->value(progdefaults.mt63_tone_duration);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* MT63_tone_duration
              { Fl_Check_Button* o = btnMT63_at500 = new Fl_Check_Button(150, 269, 200, 20, _("Allow manual tuning"));
                btnMT63_at500->down_box(FL_DOWN_BOX);
                btnMT63_at500->callback((Fl_Callback*)cb_btnMT63_at500);
                o->value(!progdefaults.mt63_at500);
              } // Fl_Check_Button* btnMT63_at500
              o->end();
            } // Fl_Group* o
            tabMT63->end();
          } // Fl_Group* tabMT63
          { tabOlivia = new Fl_Group(0, 50, 500, 320, _("Olivia"));
            tabOlivia->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 200);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Choice* o = mnuOlivia_Bandwidth = new Fl_Choice(60, 80, 85, 20, _("Bandwidth"));
                mnuOlivia_Bandwidth->tooltip(_("Select bandwidth"));
                mnuOlivia_Bandwidth->down_box(FL_BORDER_BOX);
                mnuOlivia_Bandwidth->callback((Fl_Callback*)cb_mnuOlivia_Bandwidth);
                mnuOlivia_Bandwidth->align(FL_ALIGN_RIGHT);
                o->add(szOliviaBandwidth);
                o->value(2);
              } // Fl_Choice* mnuOlivia_Bandwidth
              { Fl_Choice* o = mnuOlivia_Tones = new Fl_Choice(321, 80, 70, 20, _("Tones"));
                mnuOlivia_Tones->tooltip(_("Select number of tones"));
                mnuOlivia_Tones->down_box(FL_BORDER_BOX);
                mnuOlivia_Tones->callback((Fl_Callback*)cb_mnuOlivia_Tones);
                mnuOlivia_Tones->align(FL_ALIGN_RIGHT);
                o->add(szOliviaTones);
                o->value(2);
              } // Fl_Choice* mnuOlivia_Tones
              { Fl_Group* o = new Fl_Group(60, 119, 379, 100, _("Receive synchronizer"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Counter2* o = cntOlivia_smargin = new Fl_Counter2(80, 150, 70, 20, _("Tune margin (tone frequency spacing)"));
                cntOlivia_smargin->tooltip(_("Change ONLY to experiment"));
                cntOlivia_smargin->type(1);
                cntOlivia_smargin->box(FL_UP_BOX);
                cntOlivia_smargin->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntOlivia_smargin->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntOlivia_smargin->labeltype(FL_NORMAL_LABEL);
                cntOlivia_smargin->labelfont(0);
                cntOlivia_smargin->labelsize(14);
                cntOlivia_smargin->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntOlivia_smargin->minimum(2);
                cntOlivia_smargin->maximum(128);
                cntOlivia_smargin->step(1);
                cntOlivia_smargin->value(8);
                cntOlivia_smargin->callback((Fl_Callback*)cb_cntOlivia_smargin);
                cntOlivia_smargin->align(FL_ALIGN_RIGHT);
                cntOlivia_smargin->when(FL_WHEN_CHANGED);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntOlivia_smargin
                { Fl_Counter2* o = cntOlivia_sinteg = new Fl_Counter2(80, 180, 70, 20, _("Integration period (FEC blocks)"));
                cntOlivia_sinteg->tooltip(_("Change ONLY to experiment"));
                cntOlivia_sinteg->type(1);
                cntOlivia_sinteg->box(FL_UP_BOX);
                cntOlivia_sinteg->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntOlivia_sinteg->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntOlivia_sinteg->labeltype(FL_NORMAL_LABEL);
                cntOlivia_sinteg->labelfont(0);
                cntOlivia_sinteg->labelsize(14);
                cntOlivia_sinteg->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntOlivia_sinteg->minimum(2);
                cntOlivia_sinteg->maximum(128);
                cntOlivia_sinteg->step(1);
                cntOlivia_sinteg->value(4);
                cntOlivia_sinteg->callback((Fl_Callback*)cb_cntOlivia_sinteg);
                cntOlivia_sinteg->align(FL_ALIGN_RIGHT);
                cntOlivia_sinteg->when(FL_WHEN_CHANGED);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntOlivia_sinteg
                o->end();
              } // Fl_Group* o
              { btnOlivia_8bit = new Fl_Check_Button(60, 229, 200, 20, _("8-bit extended characters"));
                btnOlivia_8bit->tooltip(_("Enable this for Latin-1 accented characters"));
                btnOlivia_8bit->down_box(FL_DOWN_BOX);
                btnOlivia_8bit->callback((Fl_Callback*)cb_btnOlivia_8bit);
              } // Fl_Check_Button* btnOlivia_8bit
              o->end();
            } // Fl_Group* o
            tabOlivia->end();
          } // Fl_Group* tabOlivia
          { tabContestia = new Fl_Group(0, 50, 500, 320, _("Contestia"));
            tabContestia->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 200);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Choice* o = mnuContestia_Bandwidth = new Fl_Choice(60, 80, 85, 20, _("Bandwidth"));
                mnuContestia_Bandwidth->tooltip(_("Select bandwidth"));
                mnuContestia_Bandwidth->down_box(FL_BORDER_BOX);
                mnuContestia_Bandwidth->callback((Fl_Callback*)cb_mnuContestia_Bandwidth);
                mnuContestia_Bandwidth->align(FL_ALIGN_RIGHT);
                o->add(szContestiaBandwidth);
                o->value(2);
              } // Fl_Choice* mnuContestia_Bandwidth
              { Fl_Choice* o = mnuContestia_Tones = new Fl_Choice(321, 80, 70, 20, _("Tones"));
                mnuContestia_Tones->tooltip(_("Select number of tones"));
                mnuContestia_Tones->down_box(FL_BORDER_BOX);
                mnuContestia_Tones->callback((Fl_Callback*)cb_mnuContestia_Tones);
                mnuContestia_Tones->align(FL_ALIGN_RIGHT);
                o->add(szContestiaTones);
                o->value(2);
              } // Fl_Choice* mnuContestia_Tones
              { Fl_Group* o = new Fl_Group(60, 119, 379, 100, _("Receive synchronizer"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Counter2* o = cntContestia_smargin = new Fl_Counter2(80, 150, 70, 20, _("Tune margin (tone frequency spacing)"));
                cntContestia_smargin->tooltip(_("Change ONLY to experiment"));
                cntContestia_smargin->type(1);
                cntContestia_smargin->box(FL_UP_BOX);
                cntContestia_smargin->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntContestia_smargin->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntContestia_smargin->labeltype(FL_NORMAL_LABEL);
                cntContestia_smargin->labelfont(0);
                cntContestia_smargin->labelsize(14);
                cntContestia_smargin->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntContestia_smargin->minimum(2);
                cntContestia_smargin->maximum(128);
                cntContestia_smargin->step(1);
                cntContestia_smargin->value(8);
                cntContestia_smargin->callback((Fl_Callback*)cb_cntContestia_smargin);
                cntContestia_smargin->align(FL_ALIGN_RIGHT);
                cntContestia_smargin->when(FL_WHEN_CHANGED);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntContestia_smargin
                { Fl_Counter2* o = cntContestia_sinteg = new Fl_Counter2(80, 180, 70, 20, _("Integration period (FEC blocks)"));
                cntContestia_sinteg->tooltip(_("Change ONLY to experiment"));
                cntContestia_sinteg->type(1);
                cntContestia_sinteg->box(FL_UP_BOX);
                cntContestia_sinteg->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntContestia_sinteg->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntContestia_sinteg->labeltype(FL_NORMAL_LABEL);
                cntContestia_sinteg->labelfont(0);
                cntContestia_sinteg->labelsize(14);
                cntContestia_sinteg->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntContestia_sinteg->minimum(2);
                cntContestia_sinteg->maximum(128);
                cntContestia_sinteg->step(1);
                cntContestia_sinteg->value(4);
                cntContestia_sinteg->callback((Fl_Callback*)cb_cntContestia_sinteg);
                cntContestia_sinteg->align(FL_ALIGN_RIGHT);
                cntContestia_sinteg->when(FL_WHEN_CHANGED);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntContestia_sinteg
                o->end();
              } // Fl_Group* o
              { btnContestia_8bit = new Fl_Check_Button(60, 229, 200, 20, _("8-bit extended characters"));
                btnContestia_8bit->tooltip(_("Enable this for Latin-1 accented characters"));
                btnContestia_8bit->down_box(FL_DOWN_BOX);
                btnContestia_8bit->callback((Fl_Callback*)cb_btnContestia_8bit);
                btnContestia_8bit->hide();
              } // Fl_Check_Button* btnContestia_8bit
              o->end();
            } // Fl_Group* o
            tabContestia->end();
          } // Fl_Group* tabContestia
          { tabPSK = new Fl_Group(-4, 50, 521, 322, _("PSK"));
            tabPSK->hide();
            { tabsPSK = new Fl_Tabs(-4, 50, 521, 322);
              tabsPSK->selection_color((Fl_Color)FL_LIGHT1);
              { Fl_Group* o = new Fl_Group(0, 75, 500, 295, _("General"));
                o->align(FL_ALIGN_TOP_LEFT);
                { Fl_Group* o = new Fl_Group(5, 85, 490, 98, _("AFC behavior"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Counter2* o = cntSearchRange = new Fl_Counter2(15, 117, 75, 20, _("Acquisition search range (Hz)"));
                cntSearchRange->tooltip(_("Capture signals within this frequency range"));
                cntSearchRange->type(1);
                cntSearchRange->box(FL_UP_BOX);
                cntSearchRange->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntSearchRange->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntSearchRange->labeltype(FL_NORMAL_LABEL);
                cntSearchRange->labelfont(0);
                cntSearchRange->labelsize(14);
                cntSearchRange->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntSearchRange->minimum(10);
                cntSearchRange->maximum(500);
                cntSearchRange->step(10);
                cntSearchRange->value(200);
                cntSearchRange->callback((Fl_Callback*)cb_cntSearchRange);
                cntSearchRange->align(FL_ALIGN_RIGHT);
                cntSearchRange->when(FL_WHEN_CHANGED);
                o->value(progdefaults.SearchRange);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntSearchRange
                { Fl_Counter2* o = cntACQsn = new Fl_Counter2(15, 146, 75, 20, _("Acquisition S/N (dB)"));
                cntACQsn->tooltip(_("Capture signals over this threshold"));
                cntACQsn->type(1);
                cntACQsn->box(FL_UP_BOX);
                cntACQsn->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntACQsn->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntACQsn->labeltype(FL_NORMAL_LABEL);
                cntACQsn->labelfont(0);
                cntACQsn->labelsize(14);
                cntACQsn->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntACQsn->minimum(3);
                cntACQsn->maximum(20);
                cntACQsn->step(1);
                cntACQsn->value(6);
                cntACQsn->callback((Fl_Callback*)cb_cntACQsn);
                cntACQsn->align(FL_ALIGN_RIGHT);
                cntACQsn->when(FL_WHEN_CHANGED);
                o->value(progdefaults.ACQsn);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntACQsn
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(5, 183, 490, 65, _("S/N and IMD behavior"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Choice* o = mnuPSKStatusTimeout = new Fl_Choice(15, 214, 80, 20, _("after"));
                mnuPSKStatusTimeout->tooltip(_("Behavior of s/n imd"));
                mnuPSKStatusTimeout->down_box(FL_BORDER_BOX);
                mnuPSKStatusTimeout->callback((Fl_Callback*)cb_mnuPSKStatusTimeout);
                mnuPSKStatusTimeout->align(FL_ALIGN_RIGHT);
                o->add(_("Clear")); o->add(_("Dim"));
                o->value(progdefaults.StatusDim);
                } // Fl_Choice* mnuPSKStatusTimeout
                { Fl_Counter2* o = new Fl_Counter2(156, 214, 75, 20, _("seconds"));
                o->tooltip(_("Will occur after this time in seconds"));
                o->type(1);
                o->box(FL_UP_BOX);
                o->color((Fl_Color)FL_BACKGROUND_COLOR);
                o->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                o->labeltype(FL_NORMAL_LABEL);
                o->labelfont(0);
                o->labelsize(14);
                o->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                o->minimum(0);
                o->maximum(30);
                o->step(1);
                o->callback((Fl_Callback*)cb_seconds);
                o->align(FL_ALIGN_RIGHT);
                o->when(FL_WHEN_CHANGED);
                o->value(progdefaults.StatusTimeout);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(6, 250, 490, 98, _("Multi-Channel Signal Processing"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Check_Button* o = btnEnablePSKbrowsing = new Fl_Check_Button(16, 307, 180, 20, _("Multi-channel detector"));
                btnEnablePSKbrowsing->down_box(FL_DOWN_BOX);
                btnEnablePSKbrowsing->callback((Fl_Callback*)cb_btnEnablePSKbrowsing);
                o->value(progdefaults.pskbrowser_on);
                } // Fl_Check_Button* btnEnablePSKbrowsing
                { Fl_Box* o = new Fl_Box(16, 277, 440, 20, _("Disable on very slow CPUs of if signal browser is not used"));
                o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              tabsPSK->end();
            } // Fl_Tabs* tabsPSK
            tabPSK->end();
          } // Fl_Group* tabPSK
          { tabRTTY = new Fl_Group(0, 50, 500, 320, _("RTTY"));
            { Fl_Group* o = new Fl_Group(5, 60, 490, 300);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Choice* o = selShift = new Fl_Choice(15, 70, 100, 20, _("Carrier shift"));
                selShift->tooltip(_("Select carrier shift"));
                selShift->down_box(FL_BORDER_BOX);
                selShift->callback((Fl_Callback*)cb_selShift);
                selShift->align(FL_ALIGN_RIGHT);
                selShift->when(FL_WHEN_CHANGED);
                o->add(szShifts);
              } // Fl_Choice* selShift
              { Fl_Choice* o = selBaud = new Fl_Choice(15, 130, 100, 20, _("Baud rate"));
                selBaud->tooltip(_("Select carrier baudrate"));
                selBaud->down_box(FL_BORDER_BOX);
                selBaud->callback((Fl_Callback*)cb_selBaud);
                selBaud->align(FL_ALIGN_RIGHT);
                selBaud->when(FL_WHEN_CHANGED);
                o->add(szBauds);
              } // Fl_Choice* selBaud
              { Fl_Choice* o = selBits = new Fl_Choice(15, 160, 100, 20, _("Bits per character"));
                selBits->tooltip(_("Select # bits / char"));
                selBits->down_box(FL_BORDER_BOX);
                selBits->callback((Fl_Callback*)cb_selBits);
                selBits->align(FL_ALIGN_RIGHT);
                selBits->when(FL_WHEN_CHANGED);
                o->add(szSelBits);
              } // Fl_Choice* selBits
              { Fl_Choice* o = selParity = new Fl_Choice(15, 190, 100, 20, _("Parity"));
                selParity->tooltip(_("Select parity"));
                selParity->down_box(FL_BORDER_BOX);
                selParity->callback((Fl_Callback*)cb_selParity);
                selParity->align(FL_ALIGN_RIGHT);
                selParity->when(FL_WHEN_CHANGED);
                o->add(szParity);
              } // Fl_Choice* selParity
              { Fl_Choice* o = selStopBits = new Fl_Choice(15, 220, 100, 20, _("Stop bits"));
                selStopBits->tooltip(_("Select # stop bits"));
                selStopBits->down_box(FL_BORDER_BOX);
                selStopBits->callback((Fl_Callback*)cb_selStopBits);
                selStopBits->align(FL_ALIGN_RIGHT);
                selStopBits->when(FL_WHEN_CHANGED);
                o->add(szStopBits);
              } // Fl_Choice* selStopBits
              { Fl_Group* o = new Fl_Group(259, 66, 230, 70);
                o->box(FL_ENGRAVED_FRAME);
                { Fl_Check_Button* o = btnAUTOCRLF = new Fl_Check_Button(269, 77, 90, 22, _("AutoCRLF"));
                btnAUTOCRLF->tooltip(_("Add CRLF after page width characters"));
                btnAUTOCRLF->down_box(FL_DOWN_BOX);
                btnAUTOCRLF->callback((Fl_Callback*)cb_btnAUTOCRLF);
                o->value(progdefaults.rtty_autocrlf);
                } // Fl_Check_Button* btnAUTOCRLF
                { Fl_Check_Button* o = btnCRCRLF = new Fl_Check_Button(389, 77, 90, 22, _("CR-CR-LF"));
                btnCRCRLF->tooltip(_("Use \"cr cr lf\" for \"cr lf\""));
                btnCRCRLF->down_box(FL_DOWN_BOX);
                btnCRCRLF->callback((Fl_Callback*)cb_btnCRCRLF);
                btnCRCRLF->when(FL_WHEN_RELEASE_ALWAYS);
                o->value(progdefaults.rtty_crcrlf);
                } // Fl_Check_Button* btnCRCRLF
                { Fl_Counter2* o = cntrAUTOCRLF = new Fl_Counter2(339, 107, 65, 20, _("characters"));
                cntrAUTOCRLF->tooltip(_("Set page width"));
                cntrAUTOCRLF->type(1);
                cntrAUTOCRLF->box(FL_UP_BOX);
                cntrAUTOCRLF->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntrAUTOCRLF->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntrAUTOCRLF->labeltype(FL_NORMAL_LABEL);
                cntrAUTOCRLF->labelfont(0);
                cntrAUTOCRLF->labelsize(14);
                cntrAUTOCRLF->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntrAUTOCRLF->minimum(68);
                cntrAUTOCRLF->maximum(80);
                cntrAUTOCRLF->step(1);
                cntrAUTOCRLF->value(72);
                cntrAUTOCRLF->callback((Fl_Callback*)cb_cntrAUTOCRLF);
                cntrAUTOCRLF->align(FL_ALIGN_RIGHT);
                cntrAUTOCRLF->when(FL_WHEN_CHANGED);
                o->labelsize(FL_NORMAL_SIZE);
                } // Fl_Counter2* cntrAUTOCRLF
                { Fl_Box* o = new Fl_Box(269, 107, 60, 20, _("after:"));
                o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
                } // Fl_Box* o
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(259, 135, 231, 52, _("Unshift On Space"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Check_Button* o = chkUOSrx = new Fl_Check_Button(308, 153, 63, 26, _("RX"));
                chkUOSrx->tooltip(_("Revert to Unsifted char\'s on a space"));
                chkUOSrx->down_box(FL_DOWN_BOX);
                chkUOSrx->callback((Fl_Callback*)cb_chkUOSrx);
                o->value(progdefaults.UOSrx);
                } // Fl_Check_Button* chkUOSrx
                { Fl_Check_Button* o = chkUOStx = new Fl_Check_Button(398, 153, 63, 26, _("TX"));
                chkUOStx->tooltip(_("Revert to Unsifted char\'s on a space"));
                chkUOStx->down_box(FL_DOWN_BOX);
                chkUOStx->callback((Fl_Callback*)cb_chkUOStx);
                o->value(progdefaults.UOStx);
                } // Fl_Check_Button* chkUOStx
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(259, 187, 231, 52, _("Log RTTY frequency"));
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Check_Button* o = chk_useMARKfreq = new Fl_Check_Button(269, 205, 63, 26, _("Use MARK freq\'"));
                chk_useMARKfreq->tooltip(_("Revert to Unsifted char\'s on a space"));
                chk_useMARKfreq->down_box(FL_DOWN_BOX);
                chk_useMARKfreq->callback((Fl_Callback*)cb_chk_useMARKfreq);
                o->value(progdefaults.useMARKfreq);
                } // Fl_Check_Button* chk_useMARKfreq
                { Fl_Button* o = btnRTTY_mark_color = new Fl_Button(403, 208, 18, 18, _("track clr"));
                btnRTTY_mark_color->tooltip(_("Change color"));
                btnRTTY_mark_color->color((Fl_Color)2);
                btnRTTY_mark_color->callback((Fl_Callback*)cb_btnRTTY_mark_color);
                btnRTTY_mark_color->align(FL_ALIGN_RIGHT);
                o->color(fl_rgb_color(progdefaults.rttymarkRGBI.R,progdefaults.rttymarkRGBI.G,progdefaults.rttymarkRGBI.B));
                } // Fl_Button* btnRTTY_mark_color
                o->end();
              } // Fl_Group* o
              { Fl_Check_Button* o = btnPreferXhairScope = new Fl_Check_Button(15, 254, 165, 20, _("Use cross hair scope"));
                btnPreferXhairScope->tooltip(_("Default to cross hair digiscope"));
                btnPreferXhairScope->down_box(FL_DOWN_BOX);
                btnPreferXhairScope->callback((Fl_Callback*)cb_btnPreferXhairScope);
                o->value(progdefaults.PreferXhairScope);
              } // Fl_Check_Button* btnPreferXhairScope
              { Fl_Check_Button* o = chkPseudoFSK = new Fl_Check_Button(15, 284, 270, 20, _("Pseudo-FSK on right audio channel"));
                chkPseudoFSK->tooltip(_("Create square wave on right channel"));
                chkPseudoFSK->down_box(FL_DOWN_BOX);
                chkPseudoFSK->callback((Fl_Callback*)cb_chkPseudoFSK);
                o->value(progdefaults.PseudoFSK);
              } // Fl_Check_Button* chkPseudoFSK
              { Fl_Choice* o = mnuRTTYAFCSpeed = new Fl_Choice(308, 254, 80, 20, _("AFC speed"));
                mnuRTTYAFCSpeed->tooltip(_("AFC tracking speed"));
                mnuRTTYAFCSpeed->down_box(FL_BORDER_BOX);
                mnuRTTYAFCSpeed->callback((Fl_Callback*)cb_mnuRTTYAFCSpeed);
                mnuRTTYAFCSpeed->align(FL_ALIGN_RIGHT);
                o->add("Slow"); o->add("Normal"); o->add("Fast");
                o->value(progdefaults.rtty_afcspeed);
              } // Fl_Choice* mnuRTTYAFCSpeed
              { Fl_Check_Button* o = chkXagc = new Fl_Check_Button(308, 284, 62, 22, _("X-agc (hidden)"));
                chkXagc->down_box(FL_DOWN_BOX);
                chkXagc->callback((Fl_Callback*)cb_chkXagc);
                o->value(progdefaults.Xagc);
                o->hide();
              } // Fl_Check_Button* chkXagc
              { Fl_Value_Slider2* o = sldrRTTYbandwidth = new Fl_Value_Slider2(100, 325, 300, 20, _("Receive filter bandwidth"));
                sldrRTTYbandwidth->tooltip(_("Adjust the DSP bandwidth"));
                sldrRTTYbandwidth->type(1);
                sldrRTTYbandwidth->box(FL_DOWN_BOX);
                sldrRTTYbandwidth->color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrRTTYbandwidth->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                sldrRTTYbandwidth->labeltype(FL_NORMAL_LABEL);
                sldrRTTYbandwidth->labelfont(0);
                sldrRTTYbandwidth->labelsize(14);
                sldrRTTYbandwidth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                sldrRTTYbandwidth->minimum(5);
                sldrRTTYbandwidth->maximum(200);
                sldrRTTYbandwidth->step(1);
                sldrRTTYbandwidth->value(25);
                sldrRTTYbandwidth->textsize(14);
                sldrRTTYbandwidth->callback((Fl_Callback*)cb_sldrRTTYbandwidth);
                sldrRTTYbandwidth->align(FL_ALIGN_TOP_LEFT);
                sldrRTTYbandwidth->when(FL_WHEN_CHANGED);
                o->value(progdefaults.RTTY_BW);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
              } // Fl_Value_Slider2* sldrRTTYbandwidth
              { Fl_Counter2* o = selCustomShift = new Fl_Counter2(15, 100, 100, 20, _("Custom shift"));
                selCustomShift->tooltip(_("Input carrier shift"));
                selCustomShift->box(FL_UP_BOX);
                selCustomShift->color((Fl_Color)FL_BACKGROUND_COLOR);
                selCustomShift->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                selCustomShift->labeltype(FL_NORMAL_LABEL);
                selCustomShift->labelfont(0);
                selCustomShift->labelsize(14);
                selCustomShift->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                selCustomShift->minimum(10);
                selCustomShift->maximum(1000);
                selCustomShift->step(1);
                selCustomShift->value(450);
                selCustomShift->callback((Fl_Callback*)cb_selCustomShift);
                selCustomShift->align(FL_ALIGN_RIGHT);
                selCustomShift->when(FL_WHEN_CHANGED);
                o->lstep(10.0);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* selCustomShift
              o->end();
            } // Fl_Group* o
            tabRTTY->end();
          } // Fl_Group* tabRTTY
          { tabTHOR = new Fl_Group(0, 50, 500, 320, _("Thor"));
            tabTHOR->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 170);
              o->box(FL_ENGRAVED_FRAME);
              { txtTHORSecondary = new Fl_Input2(15, 87, 360, 40, _("Secondary Text"));
                txtTHORSecondary->tooltip(_("Text to send during keyboard idle times"));
                txtTHORSecondary->type(4);
                txtTHORSecondary->box(FL_DOWN_BOX);
                txtTHORSecondary->color((Fl_Color)FL_BACKGROUND2_COLOR);
                txtTHORSecondary->selection_color((Fl_Color)FL_SELECTION_COLOR);
                txtTHORSecondary->labeltype(FL_NORMAL_LABEL);
                txtTHORSecondary->labelfont(0);
                txtTHORSecondary->labelsize(14);
                txtTHORSecondary->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                txtTHORSecondary->callback((Fl_Callback*)cb_txtTHORSecondary);
                txtTHORSecondary->align(FL_ALIGN_TOP_LEFT);
                txtTHORSecondary->when(FL_WHEN_CHANGED);
                txtTHORSecondary->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* txtTHORSecondary
              { Fl_Check_Button* o = valTHOR_FILTER = new Fl_Check_Button(15, 141, 80, 20, _("Filtering"));
                valTHOR_FILTER->tooltip(_("Enable DSP prior to decoder"));
                valTHOR_FILTER->down_box(FL_DOWN_BOX);
                valTHOR_FILTER->value(1);
                valTHOR_FILTER->callback((Fl_Callback*)cb_valTHOR_FILTER);
                o->value(progdefaults.THOR_FILTER);
              } // Fl_Check_Button* valTHOR_FILTER
              { Fl_Counter2* o = valTHOR_BW = new Fl_Counter2(156, 141, 63, 20, _("Filter bandwidth factor"));
                valTHOR_BW->tooltip(_("Filter bandwidth relative to signal width"));
                valTHOR_BW->type(1);
                valTHOR_BW->box(FL_UP_BOX);
                valTHOR_BW->color((Fl_Color)FL_BACKGROUND_COLOR);
                valTHOR_BW->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valTHOR_BW->labeltype(FL_NORMAL_LABEL);
                valTHOR_BW->labelfont(0);
                valTHOR_BW->labelsize(14);
                valTHOR_BW->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valTHOR_BW->minimum(1);
                valTHOR_BW->maximum(2);
                valTHOR_BW->value(1.5);
                valTHOR_BW->callback((Fl_Callback*)cb_valTHOR_BW);
                valTHOR_BW->align(FL_ALIGN_RIGHT);
                valTHOR_BW->when(FL_WHEN_CHANGED);
                o->value(progdefaults.THOR_BW);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* valTHOR_BW
              { Fl_Value_Slider2* o = valThorCWI = new Fl_Value_Slider2(15, 194, 260, 20, _("CWI threshold"));
                valThorCWI->tooltip(_("CWI detection and suppression"));
                valThorCWI->type(1);
                valThorCWI->box(FL_DOWN_BOX);
                valThorCWI->color((Fl_Color)FL_BACKGROUND_COLOR);
                valThorCWI->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                valThorCWI->labeltype(FL_NORMAL_LABEL);
                valThorCWI->labelfont(0);
                valThorCWI->labelsize(14);
                valThorCWI->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valThorCWI->textsize(14);
                valThorCWI->callback((Fl_Callback*)cb_valThorCWI);
                valThorCWI->align(FL_ALIGN_TOP);
                valThorCWI->when(FL_WHEN_CHANGED);
                o->value(progdefaults.ThorCWI);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
              } // Fl_Value_Slider2* valThorCWI
              { Fl_Counter2* o = valTHOR_PATHS = new Fl_Counter2(353, 193, 75, 21, _("Paths (hidden)"));
                valTHOR_PATHS->type(1);
                valTHOR_PATHS->box(FL_UP_BOX);
                valTHOR_PATHS->color((Fl_Color)FL_BACKGROUND_COLOR);
                valTHOR_PATHS->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valTHOR_PATHS->labeltype(FL_NORMAL_LABEL);
                valTHOR_PATHS->labelfont(0);
                valTHOR_PATHS->labelsize(14);
                valTHOR_PATHS->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valTHOR_PATHS->minimum(4);
                valTHOR_PATHS->maximum(8);
                valTHOR_PATHS->step(1);
                valTHOR_PATHS->value(5);
                valTHOR_PATHS->callback((Fl_Callback*)cb_valTHOR_PATHS);
                valTHOR_PATHS->align(FL_ALIGN_TOP);
                valTHOR_PATHS->when(FL_WHEN_CHANGED);
                o->value(progdefaults.THOR_PATHS);
                o->labelsize(FL_NORMAL_SIZE);
                o->hide();
              } // Fl_Counter2* valTHOR_PATHS
              o->end();
            } // Fl_Group* o
            tabTHOR->end();
          } // Fl_Group* tabTHOR
          tabsModems->end();
        } // Fl_Tabs* tabsModems
        tabModems->end();
      } // Fl_Group* tabModems
      { tabRig = new Fl_Group(0, 25, 500, 345, _("Rig"));
        tabRig->tooltip(_("Transceiver control"));
        tabRig->hide();
        { tabsRig = new Fl_Tabs(0, 25, 500, 345);
          tabsRig->selection_color((Fl_Color)FL_LIGHT1);
          { Fl_Group* o = new Fl_Group(0, 50, 500, 320, _("Hardware PTT"));
            o->hide();
            { grpHWPTT = new Fl_Group(5, 100, 490, 265, _("h/w ptt device-pin"));
              grpHWPTT->box(FL_ENGRAVED_FRAME);
              grpHWPTT->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { inpTTYdev = new Fl_Input_Choice(200, 209, 160, 22, _("Device:"));
                inpTTYdev->tooltip(_("Select serial port"));
                inpTTYdev->callback((Fl_Callback*)cb_inpTTYdev);
              } // Fl_Input_Choice* inpTTYdev
              { btnRTSptt = new Fl_Round_Button(145, 248, 85, 20, _("Use RTS"));
                btnRTSptt->tooltip(_("RTS is PTT signal line"));
                btnRTSptt->down_box(FL_DOWN_BOX);
                btnRTSptt->callback((Fl_Callback*)cb_btnRTSptt);
              } // Fl_Round_Button* btnRTSptt
              { btnRTSplusV = new Fl_Round_Button(262, 248, 100, 20, _("RTS = +V"));
                btnRTSplusV->tooltip(_("Initial voltage on RTS"));
                btnRTSplusV->down_box(FL_DOWN_BOX);
                btnRTSplusV->callback((Fl_Callback*)cb_btnRTSplusV);
              } // Fl_Round_Button* btnRTSplusV
              { btnDTRptt = new Fl_Round_Button(145, 278, 85, 20, _("Use DTR"));
                btnDTRptt->tooltip(_("DTR is PTT signal line"));
                btnDTRptt->down_box(FL_DOWN_BOX);
                btnDTRptt->callback((Fl_Callback*)cb_btnDTRptt);
              } // Fl_Round_Button* btnDTRptt
              { btnDTRplusV = new Fl_Round_Button(262, 278, 100, 20, _("DTR = +V"));
                btnDTRplusV->tooltip(_("Initial voltage on DTR"));
                btnDTRplusV->down_box(FL_DOWN_BOX);
                btnDTRplusV->callback((Fl_Callback*)cb_btnDTRplusV);
              } // Fl_Round_Button* btnDTRplusV
              { btnInitHWPTT = new Fl_Button(188, 316, 113, 24, _("Initialize"));
                btnInitHWPTT->tooltip(_("Initialize the H/W PTT interface"));
                btnInitHWPTT->callback((Fl_Callback*)cb_btnInitHWPTT);
              } // Fl_Button* btnInitHWPTT
              { btnTTYptt = new Fl_Round_Button(145, 110, 220, 20, _("Use separate serial port PTT"));
                btnTTYptt->down_box(FL_DOWN_BOX);
                btnTTYptt->selection_color((Fl_Color)1);
                btnTTYptt->callback((Fl_Callback*)cb_btnTTYptt);
              } // Fl_Round_Button* btnTTYptt
              { btnUsePPortPTT = new Fl_Round_Button(145, 140, 170, 20, _("Use parallel port PTT"));
                btnUsePPortPTT->down_box(FL_DOWN_BOX);
                btnUsePPortPTT->selection_color((Fl_Color)1);
                btnUsePPortPTT->callback((Fl_Callback*)cb_btnUsePPortPTT);
              } // Fl_Round_Button* btnUsePPortPTT
              { btnUseUHrouterPTT = new Fl_Round_Button(145, 170, 170, 20, _("Use uHRouter PTT"));
                btnUseUHrouterPTT->down_box(FL_DOWN_BOX);
                btnUseUHrouterPTT->selection_color((Fl_Color)1);
                btnUseUHrouterPTT->callback((Fl_Callback*)cb_btnUseUHrouterPTT);
              } // Fl_Round_Button* btnUseUHrouterPTT
              grpHWPTT->end();
            } // Fl_Group* grpHWPTT
            { Fl_Group* o = new Fl_Group(5, 60, 490, 38);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnPTTrightchannel = new Fl_Check_Button(130, 69, 250, 20, _("PTT tone on right audio channel "));
                btnPTTrightchannel->tooltip(_("Can be used in lieu of or in addition to other PTT types"));
                btnPTTrightchannel->down_box(FL_DOWN_BOX);
                btnPTTrightchannel->callback((Fl_Callback*)cb_btnPTTrightchannel);
                o->value(progdefaults.PTTrightchannel);
              } // Fl_Check_Button* btnPTTrightchannel
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 500, 320, _("RigCAT"));
            o->tooltip(_("Rig Control using xml spec file"));
            { chkUSERIGCAT = new Fl_Check_Button(195, 60, 110, 20, _("Use RigCAT"));
              chkUSERIGCAT->tooltip(_("RigCAT used for rig control"));
              chkUSERIGCAT->down_box(FL_DOWN_BOX);
              chkUSERIGCAT->callback((Fl_Callback*)cb_chkUSERIGCAT);
            } // Fl_Check_Button* chkUSERIGCAT
            { grpRigCAT = new Fl_Group(5, 83, 490, 279);
              grpRigCAT->box(FL_ENGRAVED_FRAME);
              { Fl_Output* o = txtXmlRigFilename = new Fl_Output(15, 107, 130, 22, _("Rig description file:"));
                txtXmlRigFilename->tooltip(_("Use Open to select descriptor file"));
                txtXmlRigFilename->color((Fl_Color)FL_LIGHT2);
                txtXmlRigFilename->align(FL_ALIGN_TOP_LEFT);
                o->value(fl_filename_name(progdefaults.XmlRigFilename.c_str()));
              } // Fl_Output* txtXmlRigFilename
              { btnSelectRigXmlFile = new Fl_Button(148, 107, 60, 22, _("Open..."));
                btnSelectRigXmlFile->tooltip(_("Select rig descriptor file"));
                btnSelectRigXmlFile->callback((Fl_Callback*)cb_btnSelectRigXmlFile);
              } // Fl_Button* btnSelectRigXmlFile
              { Fl_Input_Choice* o = inpXmlRigDevice = new Fl_Input_Choice(341, 107, 144, 22, _("Device:"));
                inpXmlRigDevice->tooltip(_("Serial device"));
                inpXmlRigDevice->callback((Fl_Callback*)cb_inpXmlRigDevice);
                o->value(progdefaults.XmlRigDevice.c_str());
              } // Fl_Input_Choice* inpXmlRigDevice
              { Fl_Value_Input2* o = cntRigCatRetries = new Fl_Value_Input2(30, 150, 60, 22, _("Retries"));
                cntRigCatRetries->tooltip(_("# retries before giving up"));
                cntRigCatRetries->box(FL_DOWN_BOX);
                cntRigCatRetries->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntRigCatRetries->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntRigCatRetries->labeltype(FL_NORMAL_LABEL);
                cntRigCatRetries->labelfont(0);
                cntRigCatRetries->labelsize(14);
                cntRigCatRetries->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntRigCatRetries->maximum(1000);
                cntRigCatRetries->step(1);
                cntRigCatRetries->callback((Fl_Callback*)cb_cntRigCatRetries);
                cntRigCatRetries->align(FL_ALIGN_TOP_LEFT);
                cntRigCatRetries->when(FL_WHEN_CHANGED);
                o->value(progdefaults.RigCatRetries);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntRigCatRetries
              { Fl_Value_Input2* o = cntRigCatTimeout = new Fl_Value_Input2(148, 150, 60, 22, _("Retry interval (ms)"));
                cntRigCatTimeout->tooltip(_("Time between retires in msec"));
                cntRigCatTimeout->box(FL_DOWN_BOX);
                cntRigCatTimeout->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntRigCatTimeout->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntRigCatTimeout->labeltype(FL_NORMAL_LABEL);
                cntRigCatTimeout->labelfont(0);
                cntRigCatTimeout->labelsize(14);
                cntRigCatTimeout->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntRigCatTimeout->maximum(10000);
                cntRigCatTimeout->step(1);
                cntRigCatTimeout->callback((Fl_Callback*)cb_cntRigCatTimeout);
                cntRigCatTimeout->align(FL_ALIGN_TOP_LEFT);
                cntRigCatTimeout->when(FL_WHEN_CHANGED);
                o->value(progdefaults.RigCatTimeout);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntRigCatTimeout
              { Fl_Value_Input2* o = cntRigCatWait = new Fl_Value_Input2(30, 190, 60, 22, _("Write delay (ms)"));
                cntRigCatWait->box(FL_DOWN_BOX);
                cntRigCatWait->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntRigCatWait->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntRigCatWait->labeltype(FL_NORMAL_LABEL);
                cntRigCatWait->labelfont(0);
                cntRigCatWait->labelsize(14);
                cntRigCatWait->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntRigCatWait->maximum(10000);
                cntRigCatWait->step(1);
                cntRigCatWait->callback((Fl_Callback*)cb_cntRigCatWait);
                cntRigCatWait->align(FL_ALIGN_TOP_LEFT);
                cntRigCatWait->when(FL_WHEN_CHANGED);
                o->value(progdefaults.RigCatWait);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntRigCatWait
              { Fl_Choice* o = mnuXmlRigBaudrate = new Fl_Choice(386, 150, 99, 22, _("Baud rate:"));
                mnuXmlRigBaudrate->tooltip(_("Pick baud rate from list"));
                mnuXmlRigBaudrate->down_box(FL_BORDER_BOX);
                mnuXmlRigBaudrate->callback((Fl_Callback*)cb_mnuXmlRigBaudrate);
                o->add(szBaudRates);
                o->value(progdefaults.XmlRigBaudrate);
              } // Fl_Choice* mnuXmlRigBaudrate
              { Fl_Counter2* o = valRigCatStopbits = new Fl_Counter2(388, 184, 95, 21, _("Stopbits"));
                valRigCatStopbits->type(1);
                valRigCatStopbits->box(FL_UP_BOX);
                valRigCatStopbits->color((Fl_Color)FL_BACKGROUND_COLOR);
                valRigCatStopbits->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valRigCatStopbits->labeltype(FL_NORMAL_LABEL);
                valRigCatStopbits->labelfont(0);
                valRigCatStopbits->labelsize(14);
                valRigCatStopbits->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valRigCatStopbits->minimum(1);
                valRigCatStopbits->maximum(2);
                valRigCatStopbits->step(1);
                valRigCatStopbits->value(1);
                valRigCatStopbits->callback((Fl_Callback*)cb_valRigCatStopbits);
                valRigCatStopbits->align(FL_ALIGN_LEFT);
                valRigCatStopbits->when(FL_WHEN_CHANGED);
                o->value(progdefaults.RigCatStopbits);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* valRigCatStopbits
              { btnInitRIGCAT = new Fl_Button(365, 321, 113, 24, _("Initialize"));
                btnInitRIGCAT->tooltip(_("Initialize RigCAT interface"));
                btnInitRIGCAT->callback((Fl_Callback*)cb_btnInitRIGCAT);
              } // Fl_Button* btnInitRIGCAT
              { Fl_Check_Button* o = btnRigCatEcho = new Fl_Check_Button(50, 216, 192, 22, _("Commands are echoed"));
                btnRigCatEcho->tooltip(_("Rig or interface echos serial data"));
                btnRigCatEcho->down_box(FL_DOWN_BOX);
                btnRigCatEcho->callback((Fl_Callback*)cb_btnRigCatEcho);
                o->value(progdefaults.RigCatECHO);
              } // Fl_Check_Button* btnRigCatEcho
              { Fl_Round_Button* o = btnRigCatCMDptt = new Fl_Round_Button(256, 217, 207, 20, _("CAT command for PTT"));
                btnRigCatCMDptt->tooltip(_("PTT is a CAT command (not hardware)"));
                btnRigCatCMDptt->down_box(FL_DOWN_BOX);
                btnRigCatCMDptt->selection_color((Fl_Color)1);
                btnRigCatCMDptt->callback((Fl_Callback*)cb_btnRigCatCMDptt);
                o->value(progdefaults.RigCatCMDptt);
              } // Fl_Round_Button* btnRigCatCMDptt
              { Fl_Round_Button* o = btnRigCatRTSptt = new Fl_Round_Button(50, 250, 160, 20, _("Toggle RTS for PTT"));
                btnRigCatRTSptt->tooltip(_("RTS is ptt line"));
                btnRigCatRTSptt->down_box(FL_DOWN_BOX);
                btnRigCatRTSptt->callback((Fl_Callback*)cb_btnRigCatRTSptt);
                o->value(progdefaults.RigCatRTSptt);
              } // Fl_Round_Button* btnRigCatRTSptt
              { Fl_Round_Button* o = btnRigCatDTRptt = new Fl_Round_Button(256, 250, 160, 20, _("Toggle DTR for PTT"));
                btnRigCatDTRptt->tooltip(_("DTR is ptt line"));
                btnRigCatDTRptt->down_box(FL_DOWN_BOX);
                btnRigCatDTRptt->callback((Fl_Callback*)cb_btnRigCatDTRptt);
                o->value(progdefaults.RigCatDTRptt);
              } // Fl_Round_Button* btnRigCatDTRptt
              { Fl_Check_Button* o = btnRigCatRTSplus = new Fl_Check_Button(50, 285, 100, 20, _("RTS +12 v"));
                btnRigCatRTSplus->tooltip(_("Initial state of RTS"));
                btnRigCatRTSplus->down_box(FL_DOWN_BOX);
                btnRigCatRTSplus->callback((Fl_Callback*)cb_btnRigCatRTSplus);
                o->value(progdefaults.RigCatRTSplus);
              } // Fl_Check_Button* btnRigCatRTSplus
              { Fl_Check_Button* o = btnRigCatDTRplus = new Fl_Check_Button(256, 285, 100, 20, _("DTR +12 v"));
                btnRigCatDTRplus->tooltip(_("Initial state of DTR"));
                btnRigCatDTRplus->down_box(FL_DOWN_BOX);
                btnRigCatDTRplus->callback((Fl_Callback*)cb_btnRigCatDTRplus);
                o->value(progdefaults.RigCatDTRplus);
              } // Fl_Check_Button* btnRigCatDTRplus
              { Fl_Check_Button* o = chkRigCatRTSCTSflow = new Fl_Check_Button(50, 320, 170, 20, _("RTS/CTS flow control"));
                chkRigCatRTSCTSflow->tooltip(_("Rig uses RTS/CTS handshake"));
                chkRigCatRTSCTSflow->down_box(FL_DOWN_BOX);
                chkRigCatRTSCTSflow->callback((Fl_Callback*)cb_chkRigCatRTSCTSflow);
                o->value(progdefaults.RigCatRTSCTSflow);
              } // Fl_Check_Button* chkRigCatRTSCTSflow
              { btnRevertRIGCAT = new Fl_Button(365, 289, 113, 24, _("Revert"));
                btnRevertRIGCAT->tooltip(_("Initialize hamlib interface"));
                btnRevertRIGCAT->callback((Fl_Callback*)cb_btnRevertRIGCAT);
                btnRevertRIGCAT->deactivate();
              } // Fl_Button* btnRevertRIGCAT
              { Fl_Check_Button* o = chkRigCatVSP = new Fl_Check_Button(256, 315, 100, 25, _("VSP Enable"));
                chkRigCatVSP->tooltip(_("Virtual Serial Port Emulator - suppress WARNINGS"));
                chkRigCatVSP->down_box(FL_DOWN_BOX);
                chkRigCatVSP->callback((Fl_Callback*)cb_chkRigCatVSP);
                o->value(progdefaults.RigCatVSP);
              } // Fl_Check_Button* chkRigCatVSP
              grpRigCAT->end();
            } // Fl_Group* grpRigCAT
            o->end();
          } // Fl_Group* o
          { tabHamlib = new Fl_Group(0, 50, 500, 320, _("Hamlib"));
            tabHamlib->hide();
            { chkUSEHAMLIB = new Fl_Check_Button(195, 60, 100, 20, _("Use Hamlib"));
              chkUSEHAMLIB->tooltip(_("Hamlib used for rig control"));
              chkUSEHAMLIB->down_box(FL_DOWN_BOX);
              chkUSEHAMLIB->callback((Fl_Callback*)cb_chkUSEHAMLIB);
            } // Fl_Check_Button* chkUSEHAMLIB
            { grpHamlib = new Fl_Group(5, 83, 490, 277);
              grpHamlib->box(FL_ENGRAVED_FRAME);
              { Fl_ComboBox* o = cboHamlibRig = new Fl_ComboBox(65, 93, 160, 22, _("Rig:"));
                cboHamlibRig->tooltip(_("Select the rig by name"));
                cboHamlibRig->box(FL_DOWN_BOX);
                cboHamlibRig->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cboHamlibRig->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                cboHamlibRig->labeltype(FL_NORMAL_LABEL);
                cboHamlibRig->labelfont(0);
                cboHamlibRig->labelsize(14);
                cboHamlibRig->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cboHamlibRig->callback((Fl_Callback*)cb_cboHamlibRig);
                cboHamlibRig->align(FL_ALIGN_LEFT);
                cboHamlibRig->when(FL_WHEN_RELEASE);
                o->readonly();
                cboHamlibRig->labelsize(FL_NORMAL_SIZE);
              } // Fl_ComboBox* cboHamlibRig
              { Fl_Input_Choice* o = inpRIGdev = new Fl_Input_Choice(340, 93, 144, 22, _("Device:"));
                inpRIGdev->tooltip(_("Serial port"));
                inpRIGdev->callback((Fl_Callback*)cb_inpRIGdev);
                o->value(progdefaults.HamRigDevice.c_str());
              } // Fl_Input_Choice* inpRIGdev
              { Fl_Value_Input2* o = cntHamlibRetries = new Fl_Value_Input2(30, 133, 70, 24, _("Retries"));
                cntHamlibRetries->tooltip(_("# times to resend command before giving up"));
                cntHamlibRetries->box(FL_DOWN_BOX);
                cntHamlibRetries->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntHamlibRetries->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntHamlibRetries->labeltype(FL_NORMAL_LABEL);
                cntHamlibRetries->labelfont(0);
                cntHamlibRetries->labelsize(14);
                cntHamlibRetries->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntHamlibRetries->maximum(1000);
                cntHamlibRetries->step(1);
                cntHamlibRetries->callback((Fl_Callback*)cb_cntHamlibRetries);
                cntHamlibRetries->align(FL_ALIGN_TOP_LEFT);
                cntHamlibRetries->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HamlibRetries);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntHamlibRetries
              { Fl_Value_Input2* o = cntHamlibTimeout = new Fl_Value_Input2(155, 133, 70, 24, _("Retry Interval (ms)"));
                cntHamlibTimeout->tooltip(_("Msec\'s between retries"));
                cntHamlibTimeout->box(FL_DOWN_BOX);
                cntHamlibTimeout->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntHamlibTimeout->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntHamlibTimeout->labeltype(FL_NORMAL_LABEL);
                cntHamlibTimeout->labelfont(0);
                cntHamlibTimeout->labelsize(14);
                cntHamlibTimeout->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntHamlibTimeout->maximum(10000);
                cntHamlibTimeout->step(1);
                cntHamlibTimeout->callback((Fl_Callback*)cb_cntHamlibTimeout);
                cntHamlibTimeout->align(FL_ALIGN_TOP_LEFT);
                cntHamlibTimeout->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HamlibTimeout);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntHamlibTimeout
              { Fl_Value_Input2* o = cntHamlibWriteDelay = new Fl_Value_Input2(30, 176, 70, 24, _("Write delay (ms)"));
                cntHamlibWriteDelay->tooltip(_("Msec\'s between sequential commands"));
                cntHamlibWriteDelay->box(FL_DOWN_BOX);
                cntHamlibWriteDelay->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntHamlibWriteDelay->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntHamlibWriteDelay->labeltype(FL_NORMAL_LABEL);
                cntHamlibWriteDelay->labelfont(0);
                cntHamlibWriteDelay->labelsize(14);
                cntHamlibWriteDelay->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntHamlibWriteDelay->maximum(10000);
                cntHamlibWriteDelay->step(1);
                cntHamlibWriteDelay->callback((Fl_Callback*)cb_cntHamlibWriteDelay);
                cntHamlibWriteDelay->align(FL_ALIGN_TOP_LEFT);
                cntHamlibWriteDelay->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HamlibWriteDelay);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntHamlibWriteDelay
              { Fl_Value_Input2* o = cntHamlibWait = new Fl_Value_Input2(156, 176, 70, 24, _("Post write delay (ms)"));
                cntHamlibWait->tooltip(_("Wait interval (msecs) before reading response"));
                cntHamlibWait->box(FL_DOWN_BOX);
                cntHamlibWait->color((Fl_Color)FL_BACKGROUND2_COLOR);
                cntHamlibWait->selection_color((Fl_Color)FL_SELECTION_COLOR);
                cntHamlibWait->labeltype(FL_NORMAL_LABEL);
                cntHamlibWait->labelfont(0);
                cntHamlibWait->labelsize(14);
                cntHamlibWait->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntHamlibWait->maximum(10000);
                cntHamlibWait->step(1);
                cntHamlibWait->callback((Fl_Callback*)cb_cntHamlibWait);
                cntHamlibWait->align(FL_ALIGN_TOP_LEFT);
                cntHamlibWait->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HamlibWait);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* cntHamlibWait
              { Fl_Choice* o = mnuBaudRate = new Fl_Choice(385, 127, 99, 22, _("Baud rate:"));
                mnuBaudRate->tooltip(_("Serial port baud rate"));
                mnuBaudRate->down_box(FL_BORDER_BOX);
                mnuBaudRate->callback((Fl_Callback*)cb_mnuBaudRate);
                o->add(szBaudRates);
                o->value(progdefaults.HamRigBaudrate);
              } // Fl_Choice* mnuBaudRate
              { Fl_Counter2* o = valHamRigStopbits = new Fl_Counter2(389, 163, 95, 21, _("Stopbits"));
                valHamRigStopbits->type(1);
                valHamRigStopbits->box(FL_UP_BOX);
                valHamRigStopbits->color((Fl_Color)FL_BACKGROUND_COLOR);
                valHamRigStopbits->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                valHamRigStopbits->labeltype(FL_NORMAL_LABEL);
                valHamRigStopbits->labelfont(0);
                valHamRigStopbits->labelsize(14);
                valHamRigStopbits->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valHamRigStopbits->minimum(1);
                valHamRigStopbits->maximum(2);
                valHamRigStopbits->step(1);
                valHamRigStopbits->value(1);
                valHamRigStopbits->callback((Fl_Callback*)cb_valHamRigStopbits);
                valHamRigStopbits->align(FL_ALIGN_LEFT);
                valHamRigStopbits->when(FL_WHEN_CHANGED);
                o->value(progdefaults.HamRigStopbits);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* valHamRigStopbits
              { Fl_Counter2* o = cntHamlibTimeout0 = new Fl_Counter2(150, 140, 100, 20, _("Retry interval (ms)"));
                cntHamlibTimeout0->tooltip(_("Msec\'s between retries"));
                cntHamlibTimeout0->type(1);
                cntHamlibTimeout0->box(FL_UP_BOX);
                cntHamlibTimeout0->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntHamlibTimeout0->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntHamlibTimeout0->labeltype(FL_NORMAL_LABEL);
                cntHamlibTimeout0->labelfont(0);
                cntHamlibTimeout0->labelsize(14);
                cntHamlibTimeout0->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntHamlibTimeout0->minimum(2);
                cntHamlibTimeout0->maximum(20000);
                cntHamlibTimeout0->step(1);
                cntHamlibTimeout0->value(10);
                cntHamlibTimeout0->callback((Fl_Callback*)cb_cntHamlibTimeout0);
                cntHamlibTimeout0->align(FL_ALIGN_TOP_LEFT);
                cntHamlibTimeout0->when(FL_WHEN_CHANGED);
                cntHamlibTimeout0->hide();
                o->value(progdefaults.HamlibTimeout);
              } // Fl_Counter2* cntHamlibTimeout0
              { inpHamlibConfig = new Fl_Input2(20, 326, 320, 22, _("Advanced configuration:"));
                inpHamlibConfig->tooltip(_("Optional configuration\nin format: param=val ..."));
                inpHamlibConfig->box(FL_DOWN_BOX);
                inpHamlibConfig->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpHamlibConfig->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpHamlibConfig->labeltype(FL_NORMAL_LABEL);
                inpHamlibConfig->labelfont(0);
                inpHamlibConfig->labelsize(14);
                inpHamlibConfig->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpHamlibConfig->callback((Fl_Callback*)cb_inpHamlibConfig);
                inpHamlibConfig->align(FL_ALIGN_TOP_LEFT);
                inpHamlibConfig->when(FL_WHEN_RELEASE);
                inpHamlibConfig->value(progdefaults.HamConfig.c_str());
                inpHamlibConfig->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpHamlibConfig
              { btnInitHAMLIB = new Fl_Button(371, 325, 113, 24, _("Initialize"));
                btnInitHAMLIB->tooltip(_("Initialize hamlib interface"));
                btnInitHAMLIB->callback((Fl_Callback*)cb_btnInitHAMLIB);
              } // Fl_Button* btnInitHAMLIB
              { mnuSideband = new Fl_Choice(340, 217, 144, 22, _("Sideband:"));
                mnuSideband->tooltip(_("Force the rig sideband. Takes\neffect when rig mode changes."));
                mnuSideband->down_box(FL_BORDER_BOX);
                mnuSideband->align(FL_ALIGN_TOP_LEFT);
              } // Fl_Choice* mnuSideband
              { Fl_Round_Button* o = btnHamlibCMDptt = new Fl_Round_Button(45, 218, 200, 20, _("PTT via Hamlib command"));
                btnHamlibCMDptt->tooltip(_("PTT is a hamlib command"));
                btnHamlibCMDptt->down_box(FL_DOWN_BOX);
                btnHamlibCMDptt->selection_color((Fl_Color)1);
                btnHamlibCMDptt->callback((Fl_Callback*)cb_btnHamlibCMDptt);
                o->value(progdefaults.HamlibCMDptt);
              } // Fl_Round_Button* btnHamlibCMDptt
              { Fl_Check_Button* o = btnHamlibDTRplus = new Fl_Check_Button(45, 243, 90, 20, _("DTR +12"));
                btnHamlibDTRplus->tooltip(_("Initial state of DTR"));
                btnHamlibDTRplus->down_box(FL_DOWN_BOX);
                btnHamlibDTRplus->callback((Fl_Callback*)cb_btnHamlibDTRplus);
                o->value(progdefaults.HamlibDTRplus);
              } // Fl_Check_Button* btnHamlibDTRplus
              { Fl_Check_Button* o = chkHamlibRTSplus = new Fl_Check_Button(269, 243, 85, 20, _("RTS +12"));
                chkHamlibRTSplus->tooltip(_("Initial state of RTS"));
                chkHamlibRTSplus->down_box(FL_DOWN_BOX);
                chkHamlibRTSplus->callback((Fl_Callback*)cb_chkHamlibRTSplus);
                o->value(progdefaults.HamlibRTSplus);
              } // Fl_Check_Button* chkHamlibRTSplus
              { Fl_Check_Button* o = chkHamlibRTSCTSflow = new Fl_Check_Button(45, 271, 170, 20, _("RTS/CTS flow control"));
                chkHamlibRTSCTSflow->tooltip(_("Rig requires RTS/CTS flow control"));
                chkHamlibRTSCTSflow->down_box(FL_DOWN_BOX);
                chkHamlibRTSCTSflow->callback((Fl_Callback*)cb_chkHamlibRTSCTSflow);
                o->value(progdefaults.HamlibRTSCTSflow);
                if (o->value()) chkHamlibRTSplus->deactivate();
              } // Fl_Check_Button* chkHamlibRTSCTSflow
              { Fl_Check_Button* o = chkHamlibXONXOFFflow = new Fl_Check_Button(269, 271, 185, 20, _("XON/XOFF flow control"));
                chkHamlibXONXOFFflow->tooltip(_("Rig requires Xon/Xoff flow control"));
                chkHamlibXONXOFFflow->down_box(FL_DOWN_BOX);
                chkHamlibXONXOFFflow->callback((Fl_Callback*)cb_chkHamlibXONXOFFflow);
                o->value(progdefaults.HamlibXONXOFFflow);
              } // Fl_Check_Button* chkHamlibXONXOFFflow
              { btnRevertHAMLIB = new Fl_Button(371, 294, 113, 24, _("Revert"));
                btnRevertHAMLIB->tooltip(_("Initialize hamlib interface"));
                btnRevertHAMLIB->callback((Fl_Callback*)cb_btnRevertHAMLIB);
                btnRevertHAMLIB->deactivate();
              } // Fl_Button* btnRevertHAMLIB
              grpHamlib->end();
            } // Fl_Group* grpHamlib
            tabHamlib->end();
          } // Fl_Group* tabHamlib
          { Fl_Group* o = new Fl_Group(0, 50, 500, 320, _("MemMap"));
            o->hide();
            { grpMemmap = new Fl_Group(5, 60, 490, 185);
              grpMemmap->box(FL_ENGRAVED_FRAME);
              { Fl_Output* o = new Fl_Output(160, 79, 190, 58);
                o->type(12);
                o->box(FL_BORDER_BOX);
                o->color((Fl_Color)FL_LIGHT1);
                o->value(_("Control via Memory Mapped\nshared variables\ni.e.: Kachina program"));
              } // Fl_Output* o
              { Fl_Check_Button* o = chkUSEMEMMAP = new Fl_Check_Button(160, 147, 120, 20, _("Use Memmap"));
                chkUSEMEMMAP->tooltip(_("Rig control via memory mapped Kachina"));
                chkUSEMEMMAP->down_box(FL_DOWN_BOX);
                chkUSEMEMMAP->callback((Fl_Callback*)cb_chkUSEMEMMAP);
                o->value(progdefaults.chkUSEMEMMAPis);
              } // Fl_Check_Button* chkUSEMEMMAP
              { btnMEMMAPptt = new Fl_Round_Button(160, 177, 150, 20, _("Use Memmap PTT"));
                btnMEMMAPptt->down_box(FL_DOWN_BOX);
                btnMEMMAPptt->selection_color((Fl_Color)1);
                btnMEMMAPptt->callback((Fl_Callback*)cb_btnMEMMAPptt);
              } // Fl_Round_Button* btnMEMMAPptt
              { btnInitMEMMAP = new Fl_Button(197, 207, 113, 24, _("Initialize"));
                btnInitMEMMAP->tooltip(_("Initialize Memmap interface"));
                btnInitMEMMAP->callback((Fl_Callback*)cb_btnInitMEMMAP);
              } // Fl_Button* btnInitMEMMAP
              grpMemmap->end();
            } // Fl_Group* grpMemmap
            o->end();
          } // Fl_Group* o
          { tabXMLRPC = new Fl_Group(0, 50, 500, 320, _("XML-RPC"));
            tabXMLRPC->hide();
            { grpXMLRPC = new Fl_Group(5, 60, 490, 160);
              grpXMLRPC->box(FL_ENGRAVED_FRAME);
              { Fl_Output* o = new Fl_Output(160, 79, 190, 58);
                o->type(12);
                o->box(FL_BORDER_BOX);
                o->color((Fl_Color)FL_LIGHT1);
                o->value(_("Rig control via external\nprogram using xmlrpc\nremote calls."));
              } // Fl_Output* o
              { chkUSEXMLRPC = new Fl_Check_Button(160, 147, 183, 20, _("Use XML-RPC program"));
                chkUSEXMLRPC->tooltip(_("Experimental"));
                chkUSEXMLRPC->down_box(FL_DOWN_BOX);
                chkUSEXMLRPC->callback((Fl_Callback*)cb_chkUSEXMLRPC);
              } // Fl_Check_Button* chkUSEXMLRPC
              { btnInitXMLRPC = new Fl_Button(201, 183, 113, 24, _("Initialize"));
                btnInitXMLRPC->tooltip(_("Initialize XML-RPC rig control"));
                btnInitXMLRPC->callback((Fl_Callback*)cb_btnInitXMLRPC);
              } // Fl_Button* btnInitXMLRPC
              grpXMLRPC->end();
            } // Fl_Group* grpXMLRPC
            tabXMLRPC->end();
          } // Fl_Group* tabXMLRPC
          tabsRig->end();
        } // Fl_Tabs* tabsRig
        tabRig->end();
      } // Fl_Group* tabRig
      { tabSoundCard = new Fl_Group(0, 25, 500, 345, _("Audio"));
        tabSoundCard->tooltip(_("Audio devices"));
        tabSoundCard->hide();
        { tabsSoundCard = new Fl_Tabs(0, 25, 500, 345);
          tabsSoundCard->selection_color((Fl_Color)FL_LIGHT1);
          { tabAudio = new Fl_Group(0, 50, 500, 320, _("Devices"));
            { AudioOSS = new Fl_Group(5, 60, 490, 45);
              AudioOSS->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[0] = new Fl_Round_Button(15, 70, 53, 25, _("OSS"));
                btnAudioIO[0]->tooltip(_("Use OSS audio server"));
                btnAudioIO[0]->down_box(FL_DOWN_BOX);
                btnAudioIO[0]->selection_color((Fl_Color)1);
                btnAudioIO[0]->callback((Fl_Callback*)cb_btnAudioIO);
              } // Fl_Round_Button* btnAudioIO[0]
              { Fl_Input_Choice* o = menuOSSDev = new Fl_Input_Choice(375, 70, 110, 25, _("Device:"));
                menuOSSDev->tooltip(_("Select device"));
                menuOSSDev->callback((Fl_Callback*)cb_menuOSSDev);
                o->value(progdefaults.OSSdevice.c_str());
              } // Fl_Input_Choice* menuOSSDev
              AudioOSS->end();
            } // Fl_Group* AudioOSS
            { AudioPort = new Fl_Group(5, 105, 490, 80);
              AudioPort->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[1] = new Fl_Round_Button(15, 133, 95, 25, _("PortAudio"));
                btnAudioIO[1]->tooltip(_("Use Port Audio server"));
                btnAudioIO[1]->down_box(FL_DOWN_BOX);
                btnAudioIO[1]->selection_color((Fl_Color)1);
                btnAudioIO[1]->callback((Fl_Callback*)cb_btnAudioIO1);
              } // Fl_Round_Button* btnAudioIO[1]
              { menuPortInDev = new Fl_Choice(215, 115, 270, 25, _("Capture:"));
                menuPortInDev->tooltip(_("Audio input device"));
                menuPortInDev->down_box(FL_BORDER_BOX);
                menuPortInDev->callback((Fl_Callback*)cb_menuPortInDev);
              } // Fl_Choice* menuPortInDev
              { menuPortOutDev = new Fl_Choice(215, 150, 270, 25, _("Playback:"));
                menuPortOutDev->tooltip(_("Audio output device"));
                menuPortOutDev->down_box(FL_BORDER_BOX);
                menuPortOutDev->callback((Fl_Callback*)cb_menuPortOutDev);
              } // Fl_Choice* menuPortOutDev
              AudioPort->end();
            } // Fl_Group* AudioPort
            { AudioPulse = new Fl_Group(5, 185, 490, 45);
              AudioPulse->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[2] = new Fl_Round_Button(15, 196, 100, 25, _("PulseAudio"));
                btnAudioIO[2]->tooltip(_("Use Pulse Audio server"));
                btnAudioIO[2]->down_box(FL_DOWN_BOX);
                btnAudioIO[2]->selection_color((Fl_Color)1);
                btnAudioIO[2]->callback((Fl_Callback*)cb_btnAudioIO2);
              } // Fl_Round_Button* btnAudioIO[2]
              { Fl_Input2* o = inpPulseServer = new Fl_Input2(260, 196, 225, 25, _("Server string:"));
                inpPulseServer->tooltip(_("Leave this blank or refer to\nhttp://www.pulseaudio.org/wiki/ServerStrings"));
                inpPulseServer->box(FL_DOWN_BOX);
                inpPulseServer->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpPulseServer->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpPulseServer->labeltype(FL_NORMAL_LABEL);
                inpPulseServer->labelfont(0);
                inpPulseServer->labelsize(14);
                inpPulseServer->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpPulseServer->callback((Fl_Callback*)cb_inpPulseServer);
                inpPulseServer->align(FL_ALIGN_LEFT);
                inpPulseServer->when(FL_WHEN_RELEASE);
                o->value(progdefaults.PulseServer.c_str());
                inpPulseServer->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpPulseServer
              AudioPulse->end();
            } // Fl_Group* AudioPulse
            { AudioNull = new Fl_Group(5, 230, 490, 45);
              AudioNull->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[3] = new Fl_Round_Button(16, 240, 100, 25, _("File I/O only"));
                btnAudioIO[3]->tooltip(_("NO AUDIO DEVICE AVAILABLE (or testing)"));
                btnAudioIO[3]->down_box(FL_DOWN_BOX);
                btnAudioIO[3]->selection_color((Fl_Color)1);
                btnAudioIO[3]->callback((Fl_Callback*)cb_btnAudioIO3);
              } // Fl_Round_Button* btnAudioIO[3]
              AudioNull->end();
            } // Fl_Group* AudioNull
            tabAudio->end();
          } // Fl_Group* tabAudio
          { tabAudioOpt = new Fl_Group(0, 50, 500, 320, _("Settings"));
            tabAudioOpt->hide();
            { grpAudioSampleRate = new Fl_Group(5, 60, 490, 90, _("Sample rate"));
              grpAudioSampleRate->box(FL_ENGRAVED_FRAME);
              grpAudioSampleRate->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Choice* o = menuInSampleRate = new Fl_Choice(15, 89, 100, 20, _("Capture"));
                menuInSampleRate->tooltip(_("Force a specific sample rate. Select \"Native\" if \"Auto\"\ndoes not work we\
ll with your audio device."));
                menuInSampleRate->down_box(FL_BORDER_BOX);
                menuInSampleRate->callback((Fl_Callback*)cb_menuInSampleRate);
                menuInSampleRate->align(FL_ALIGN_RIGHT);
                //extern Fl_Menu_Item sample_rate_menu[];
                //o->menu(sample_rate_menu);
                o->clear_changed();
              } // Fl_Choice* menuInSampleRate
              { Fl_Choice* o = menuOutSampleRate = new Fl_Choice(15, 119, 100, 20, _("Playback"));
                menuOutSampleRate->down_box(FL_BORDER_BOX);
                menuOutSampleRate->callback((Fl_Callback*)cb_menuOutSampleRate);
                menuOutSampleRate->align(FL_ALIGN_RIGHT);
                //extern Fl_Menu_Item sample_rate_menu[];
                //o->menu(sample_rate_menu);
                o->clear_changed();
                o->tooltip(menuInSampleRate->tooltip());
              } // Fl_Choice* menuOutSampleRate
              { menuSampleConverter = new Fl_Choice(269, 89, 216, 20, _("Converter"));
                menuSampleConverter->tooltip(_("Set the type of resampler used of offset correction"));
                menuSampleConverter->down_box(FL_BORDER_BOX);
                menuSampleConverter->callback((Fl_Callback*)cb_menuSampleConverter);
                menuSampleConverter->align(FL_ALIGN_TOP);
              } // Fl_Choice* menuSampleConverter
              grpAudioSampleRate->end();
            } // Fl_Group* grpAudioSampleRate
            { Fl_Group* o = new Fl_Group(5, 150, 490, 62, _("Corrections"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Spinner2* o = cntRxRateCorr = new Fl_Spinner2(15, 180, 85, 20, _("RX ppm"));
                cntRxRateCorr->tooltip(_("RX sound card correction"));
                cntRxRateCorr->box(FL_NO_BOX);
                cntRxRateCorr->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntRxRateCorr->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                cntRxRateCorr->labeltype(FL_NORMAL_LABEL);
                cntRxRateCorr->labelfont(0);
                cntRxRateCorr->labelsize(14);
                cntRxRateCorr->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntRxRateCorr->callback((Fl_Callback*)cb_cntRxRateCorr);
                cntRxRateCorr->align(FL_ALIGN_RIGHT);
                cntRxRateCorr->when(FL_WHEN_RELEASE);
                o->step(1);
                o->minimum(-50000);
                o->maximum(50000);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* cntRxRateCorr
              { Fl_Spinner2* o = cntTxRateCorr = new Fl_Spinner2(176, 180, 85, 20, _("TX ppm"));
                cntTxRateCorr->tooltip(_("TX sound card correction"));
                cntTxRateCorr->box(FL_NO_BOX);
                cntTxRateCorr->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntTxRateCorr->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                cntTxRateCorr->labeltype(FL_NORMAL_LABEL);
                cntTxRateCorr->labelfont(0);
                cntTxRateCorr->labelsize(14);
                cntTxRateCorr->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntTxRateCorr->callback((Fl_Callback*)cb_cntTxRateCorr);
                cntTxRateCorr->align(FL_ALIGN_RIGHT);
                cntTxRateCorr->when(FL_WHEN_RELEASE);
                o->step(1);
                o->minimum(-50000);
                o->maximum(50000);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* cntTxRateCorr
              { Fl_Spinner2* o = cntTxOffset = new Fl_Spinner2(338, 180, 85, 20, _("TX offset"));
                cntTxOffset->tooltip(_("Difference between Rx & Tx freq (rig offset)"));
                cntTxOffset->box(FL_NO_BOX);
                cntTxOffset->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntTxOffset->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
                cntTxOffset->labeltype(FL_NORMAL_LABEL);
                cntTxOffset->labelfont(0);
                cntTxOffset->labelsize(14);
                cntTxOffset->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntTxOffset->callback((Fl_Callback*)cb_cntTxOffset);
                cntTxOffset->align(FL_ALIGN_RIGHT);
                cntTxOffset->when(FL_WHEN_RELEASE);
                o->value(progdefaults.TxOffset);
                o->step(1);
                o->minimum(-50); o->maximum(50);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Spinner2* cntTxOffset
              o->end();
            } // Fl_Group* o
            { chkAudioStereoOut = new Fl_Check_Button(15, 222, 220, 20, _("Enable right audio channel"));
              chkAudioStereoOut->down_box(FL_DOWN_BOX);
              chkAudioStereoOut->callback((Fl_Callback*)cb_chkAudioStereoOut);
              chkAudioStereoOut->value(progdefaults.out_channels == 2);
            } // Fl_Check_Button* chkAudioStereoOut
            tabAudioOpt->end();
          } // Fl_Group* tabAudioOpt
          { tabMixer = new Fl_Group(0, 50, 500, 320, _("Mixer"));
            tabMixer->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 145, _("OSS mixer"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnMixer = new Fl_Check_Button(15, 89, 125, 25, _("Manage mixer"));
                btnMixer->tooltip(_("Add mixer controls to main dialog"));
                btnMixer->down_box(FL_DOWN_BOX);
                btnMixer->callback((Fl_Callback*)cb_btnMixer);
                o->value(progdefaults.EnableMixer);
              } // Fl_Check_Button* btnMixer
              { Fl_Input_Choice* o = menuMix = new Fl_Input_Choice(161, 132, 110, 25, _("Device:"));
                menuMix->tooltip(_("Select Mixer device"));
                menuMix->callback((Fl_Callback*)cb_menuMix);
                o->value(progdefaults.MXdevice.c_str());
              } // Fl_Input_Choice* menuMix
              { btnMicIn = new Fl_Light_Button(281, 93, 74, 25, _("Mic In"));
                btnMicIn->tooltip(_("Use microphone input"));
                btnMicIn->callback((Fl_Callback*)cb_btnMicIn);
              } // Fl_Light_Button* btnMicIn
              { btnLineIn = new Fl_Light_Button(281, 132, 74, 25, _("Line In"));
                btnLineIn->tooltip(_("Use Line-In device"));
                btnLineIn->selection_color((Fl_Color)3);
                btnLineIn->callback((Fl_Callback*)cb_btnLineIn);
              } // Fl_Light_Button* btnLineIn
              { Fl_Value_Slider2* o = valPCMvolume = new Fl_Value_Slider2(15, 167, 340, 20, _("PCM"));
                valPCMvolume->tooltip(_("Set the sound card PCM level"));
                valPCMvolume->type(1);
                valPCMvolume->box(FL_DOWN_BOX);
                valPCMvolume->color((Fl_Color)FL_BACKGROUND_COLOR);
                valPCMvolume->selection_color((Fl_Color)FL_SELECTION_COLOR);
                valPCMvolume->labeltype(FL_NORMAL_LABEL);
                valPCMvolume->labelfont(0);
                valPCMvolume->labelsize(14);
                valPCMvolume->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valPCMvolume->value(0.8);
                valPCMvolume->textsize(14);
                valPCMvolume->callback((Fl_Callback*)cb_valPCMvolume);
                valPCMvolume->align(FL_ALIGN_RIGHT);
                valPCMvolume->when(FL_WHEN_CHANGED);
                o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
              } // Fl_Value_Slider2* valPCMvolume
              o->end();
            } // Fl_Group* o
            tabMixer->end();
          } // Fl_Group* tabMixer
          { tabTxLevel = new Fl_Group(0, 50, 500, 320, _("TxLevel"));
            tabTxLevel->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 86, _("Tx Attenuator"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Counter* o = valTxLevel = new Fl_Counter(196, 85, 120, 21, _("Tx Atten (dB)"));
                valTxLevel->minimum(-30);
                valTxLevel->maximum(0);
                valTxLevel->value(-6);
                valTxLevel->callback((Fl_Callback*)cb_valTxLevel);
                o->value(progdefaults.txlevel);
                o->lstep(1.0);
              } // Fl_Counter* valTxLevel
              o->end();
            } // Fl_Group* o
            tabTxLevel->end();
          } // Fl_Group* tabTxLevel
          tabsSoundCard->end();
        } // Fl_Tabs* tabsSoundCard
        tabSoundCard->end();
      } // Fl_Group* tabSoundCard
      { tabID = new Fl_Group(0, 25, 500, 346, _("ID"));
        tabID->hide();
        { Fl_Group* o = new Fl_Group(5, 35, 490, 103, _("Video Preamble ID"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { btnsendid = new Fl_Check_Button(15, 58, 150, 20, _("Transmit mode ID"));
            btnsendid->tooltip(_("Waterfall video ID"));
            btnsendid->down_box(FL_DOWN_BOX);
            btnsendid->callback((Fl_Callback*)cb_btnsendid);
          } // Fl_Check_Button* btnsendid
          { Fl_Check_Button* o = btnsendvideotext = new Fl_Check_Button(15, 83, 155, 20, _("Transmit video text"));
            btnsendvideotext->tooltip(_("Waterfall video text"));
            btnsendvideotext->down_box(FL_DOWN_BOX);
            btnsendvideotext->callback((Fl_Callback*)cb_btnsendvideotext);
            o->value(progdefaults.sendtextid);
          } // Fl_Check_Button* btnsendvideotext
          { Fl_Input2* o = valVideotext = new Fl_Input2(182, 83, 161, 20, _(":"));
            valVideotext->tooltip(_("Limit to a few characters,\nas in CQEM or IOTA etc."));
            valVideotext->box(FL_DOWN_BOX);
            valVideotext->color((Fl_Color)FL_BACKGROUND2_COLOR);
            valVideotext->selection_color((Fl_Color)FL_SELECTION_COLOR);
            valVideotext->labeltype(FL_NORMAL_LABEL);
            valVideotext->labelfont(0);
            valVideotext->labelsize(14);
            valVideotext->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            valVideotext->callback((Fl_Callback*)cb_valVideotext);
            valVideotext->align(FL_ALIGN_LEFT);
            valVideotext->when(FL_WHEN_RELEASE);
            o->value(progdefaults.strTextid.c_str());
            valVideotext->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* valVideotext
          { Fl_Check_Button* o = chkID_SMALL = new Fl_Check_Button(15, 109, 120, 20, _("Use small font"));
            chkID_SMALL->tooltip(_("ON - small font\nOFF - large font"));
            chkID_SMALL->down_box(FL_DOWN_BOX);
            chkID_SMALL->value(1);
            chkID_SMALL->callback((Fl_Callback*)cb_chkID_SMALL);
            o->value(progdefaults.ID_SMALL);
          } // Fl_Check_Button* chkID_SMALL
          { Fl_Value_Slider2* o = sldrVideowidth = new Fl_Value_Slider2(243, 109, 100, 20, _("Chars/Row:"));
            sldrVideowidth->tooltip(_("Set the number of characters per row"));
            sldrVideowidth->type(1);
            sldrVideowidth->box(FL_DOWN_BOX);
            sldrVideowidth->color((Fl_Color)FL_BACKGROUND_COLOR);
            sldrVideowidth->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
            sldrVideowidth->labeltype(FL_NORMAL_LABEL);
            sldrVideowidth->labelfont(0);
            sldrVideowidth->labelsize(14);
            sldrVideowidth->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            sldrVideowidth->minimum(1);
            sldrVideowidth->maximum(8);
            sldrVideowidth->step(1);
            sldrVideowidth->value(4);
            sldrVideowidth->textsize(14);
            sldrVideowidth->callback((Fl_Callback*)cb_sldrVideowidth);
            sldrVideowidth->align(FL_ALIGN_LEFT);
            sldrVideowidth->when(FL_WHEN_CHANGED);
            o->value(progdefaults.videowidth);
            o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
          } // Fl_Value_Slider2* sldrVideowidth
          { Fl_Check_Button* o = btn_vidlimit = new Fl_Check_Button(352, 85, 110, 15, _("500 Hz limit"));
            btn_vidlimit->down_box(FL_DOWN_BOX);
            btn_vidlimit->callback((Fl_Callback*)cb_btn_vidlimit);
            o->value(progdefaults.vidlimit);
          } // Fl_Check_Button* btn_vidlimit
          { Fl_Check_Button* o = btn_vidmodelimit = new Fl_Check_Button(352, 111, 110, 15, _("Mode width limit"));
            btn_vidmodelimit->down_box(FL_DOWN_BOX);
            btn_vidmodelimit->callback((Fl_Callback*)cb_btn_vidmodelimit);
            o->value(progdefaults.vidmodelimit);
          } // Fl_Check_Button* btn_vidmodelimit
          { bVideoIDModes = new Fl_Button(223, 58, 120, 20, _("Video ID modes"));
            bVideoIDModes->callback((Fl_Callback*)cb_bVideoIDModes);
          } // Fl_Button* bVideoIDModes
          o->end();
        } // Fl_Group* o
        { sld = new Fl_Group(5, 138, 490, 60, _("CW Postamble ID"));
          sld->box(FL_ENGRAVED_FRAME);
          sld->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Check_Button* o = btnCWID = new Fl_Check_Button(15, 165, 140, 20, _("Transmit callsign"));
            btnCWID->tooltip(_("Send Callsign in CW at end of every transmission"));
            btnCWID->down_box(FL_DOWN_BOX);
            btnCWID->callback((Fl_Callback*)cb_btnCWID);
            o->value(progdefaults.CWid);
          } // Fl_Check_Button* btnCWID
          { Fl_Value_Slider2* o = sldrCWIDwpm = new Fl_Value_Slider2(165, 165, 180, 20, _("Speed (WPM):"));
            sldrCWIDwpm->tooltip(_("Send at this WPM"));
            sldrCWIDwpm->type(1);
            sldrCWIDwpm->box(FL_DOWN_BOX);
            sldrCWIDwpm->color((Fl_Color)FL_BACKGROUND_COLOR);
            sldrCWIDwpm->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
            sldrCWIDwpm->labeltype(FL_NORMAL_LABEL);
            sldrCWIDwpm->labelfont(0);
            sldrCWIDwpm->labelsize(14);
            sldrCWIDwpm->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            sldrCWIDwpm->minimum(15);
            sldrCWIDwpm->maximum(40);
            sldrCWIDwpm->step(1);
            sldrCWIDwpm->value(18);
            sldrCWIDwpm->textsize(14);
            sldrCWIDwpm->callback((Fl_Callback*)cb_sldrCWIDwpm);
            sldrCWIDwpm->align(FL_ALIGN_TOP);
            sldrCWIDwpm->when(FL_WHEN_CHANGED);
            o->value(progdefaults.CWIDwpm);
            o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
          } // Fl_Value_Slider2* sldrCWIDwpm
          { bCWIDModes = new Fl_Button(365, 165, 120, 20, _("CW ID modes"));
            bCWIDModes->callback((Fl_Callback*)cb_bCWIDModes);
          } // Fl_Button* bCWIDModes
          sld->end();
        } // Fl_Group* sld
        { Fl_Group* o = new Fl_Group(5, 198, 295, 167, _("Reed-Solomon ID (Rx)"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Check_Button* o = chkRSidWideSearch = new Fl_Check_Button(15, 247, 270, 20, _("Detector searches entire passband"));
            chkRSidWideSearch->tooltip(_("ON - search over entire waterfall\nOFF - limit search to +/- 200 Hz"));
            chkRSidWideSearch->down_box(FL_DOWN_BOX);
            chkRSidWideSearch->callback((Fl_Callback*)cb_chkRSidWideSearch);
            o->value(progdefaults.rsidWideSearch);
          } // Fl_Check_Button* chkRSidWideSearch
          { chkRSidMark = new Fl_Check_Button(15, 270, 270, 20, _("Mark previous frequency and mode"));
            chkRSidMark->tooltip(_("Insert RX text marker before\nchanging frequency and modem"));
            chkRSidMark->down_box(FL_DOWN_BOX);
            chkRSidMark->callback((Fl_Callback*)cb_chkRSidMark);
            chkRSidMark->value(progdefaults.rsid_mark);
          } // Fl_Check_Button* chkRSidMark
          { chkRSidAutoDisable = new Fl_Check_Button(15, 293, 200, 20, _("Reception disables detector"));
            chkRSidAutoDisable->tooltip(_("Disable further detection when RSID is received"));
            chkRSidAutoDisable->down_box(FL_DOWN_BOX);
            chkRSidAutoDisable->callback((Fl_Callback*)cb_chkRSidAutoDisable);
            if (progdefaults.rsid_notify_only) progdefaults.rsid_auto_disable = false;
            chkRSidAutoDisable->value(progdefaults.rsid_auto_disable);
            if (progdefaults.rsid_notify_only) chkRSidAutoDisable->deactivate();
          } // Fl_Check_Button* chkRSidAutoDisable
          { chkRSidNotifyOnly = new Fl_Check_Button(15, 317, 155, 20, _("Notifications only"));
            chkRSidNotifyOnly->tooltip(_("Check this to be notified when an RSID is received\nwithout changing modem an\
d frequency"));
            chkRSidNotifyOnly->down_box(FL_DOWN_BOX);
            chkRSidNotifyOnly->callback((Fl_Callback*)cb_chkRSidNotifyOnly);
            chkRSidNotifyOnly->value(progdefaults.rsid_notify_only);
          } // Fl_Check_Button* chkRSidNotifyOnly
          { bRSIDRxModes = new Fl_Button(15, 224, 130, 20, _("Receive modes"));
            bRSIDRxModes->callback((Fl_Callback*)cb_bRSIDRxModes);
          } // Fl_Button* bRSIDRxModes
          { Fl_Value_Slider2* o = sldrRSIDsquelch = new Fl_Value_Slider2(15, 339, 144, 20, _("Squelch open (sec)"));
            sldrRSIDsquelch->tooltip(_("Open squelch for nn sec if RSID detected"));
            sldrRSIDsquelch->type(1);
            sldrRSIDsquelch->box(FL_DOWN_BOX);
            sldrRSIDsquelch->color((Fl_Color)FL_BACKGROUND_COLOR);
            sldrRSIDsquelch->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
            sldrRSIDsquelch->labeltype(FL_NORMAL_LABEL);
            sldrRSIDsquelch->labelfont(0);
            sldrRSIDsquelch->labelsize(14);
            sldrRSIDsquelch->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            sldrRSIDsquelch->maximum(20);
            sldrRSIDsquelch->step(1);
            sldrRSIDsquelch->textsize(14);
            sldrRSIDsquelch->callback((Fl_Callback*)cb_sldrRSIDsquelch);
            sldrRSIDsquelch->align(FL_ALIGN_RIGHT);
            sldrRSIDsquelch->when(FL_WHEN_CHANGED);
            o->value(progdefaults.rsid_squelch);
            o->labelsize(FL_NORMAL_SIZE); o->textsize(FL_NORMAL_SIZE);
          } // Fl_Value_Slider2* sldrRSIDsquelch
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(300, 198, 195, 85, _("Reed-Solomon ID (Tx)"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { bRSIDTxModes = new Fl_Button(328, 233, 130, 20, _("Transmit modes"));
            bRSIDTxModes->callback((Fl_Callback*)cb_bRSIDTxModes);
          } // Fl_Button* bRSIDTxModes
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(300, 284, 195, 80, _("Pre-Signal Tone"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Counter* o = val_pretone = new Fl_Counter(323, 310, 140, 21, _("Seconds"));
            val_pretone->tooltip(_("Use for triggering amplifier carrier detect"));
            val_pretone->minimum(0);
            val_pretone->maximum(10);
            val_pretone->callback((Fl_Callback*)cb_val_pretone);
            o->value(progdefaults.pretone);
          } // Fl_Counter* val_pretone
          o->end();
        } // Fl_Group* o
        tabID->end();
      } // Fl_Group* tabID
      { tabMisc = new Fl_Group(0, 25, 500, 345, _("Misc"));
        tabMisc->hide();
        { tabsMisc = new Fl_Tabs(0, 25, 500, 345);
          tabsMisc->selection_color((Fl_Color)FL_LIGHT1);
          { tabCPUspeed = new Fl_Group(0, 50, 500, 320, _("CPU"));
            { Fl_Group* o = new Fl_Group(5, 60, 490, 51);
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chkSlowCpu = new Fl_Check_Button(151, 75, 225, 20, _("Slow CPU (less than 700MHz)"));
                chkSlowCpu->tooltip(_("Enable if you\'re computer does not decode properly"));
                chkSlowCpu->down_box(FL_DOWN_BOX);
                chkSlowCpu->callback((Fl_Callback*)cb_chkSlowCpu);
                o->value(progdefaults.slowcpu);
              } // Fl_Check_Button* chkSlowCpu
              o->end();
            } // Fl_Group* o
            tabCPUspeed->end();
          } // Fl_Group* tabCPUspeed
          { tabNBEMS = new Fl_Group(0, 50, 500, 320, _("NBEMS"));
            tabNBEMS->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 75, _("NBEMS data file interface"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chkAutoExtract = new Fl_Check_Button(25, 95, 75, 20, _("Enable"));
                chkAutoExtract->tooltip(_("Extract files for use with external \"wrap / flmsg\" program"));
                chkAutoExtract->down_box(FL_DOWN_BOX);
                chkAutoExtract->callback((Fl_Callback*)cb_chkAutoExtract);
                o->value(progdefaults.autoextract);
              } // Fl_Check_Button* chkAutoExtract
              { Fl_Check_Button* o = chk_open_wrap_folder = new Fl_Check_Button(259, 95, 146, 20, _("Open message folder"));
                chk_open_wrap_folder->tooltip(_("Opens NBEMS file folder upon successful capture"));
                chk_open_wrap_folder->down_box(FL_DOWN_BOX);
                chk_open_wrap_folder->callback((Fl_Callback*)cb_chk_open_wrap_folder);
                o->value(progdefaults.open_nbems_folder);
              } // Fl_Check_Button* chk_open_wrap_folder
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 136, 490, 95, _("Reception of flmsg file"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chk_open_flmsg = new Fl_Check_Button(25, 163, 136, 20, _("Open with flmsg"));
                chk_open_flmsg->tooltip(_("Open message with flmsg"));
                chk_open_flmsg->down_box(FL_DOWN_BOX);
                chk_open_flmsg->callback((Fl_Callback*)cb_chk_open_flmsg);
                o->value(progdefaults.open_flmsg);
              } // Fl_Check_Button* chk_open_flmsg
              { Fl_Input2* o = txt_flmsg_pathname = new Fl_Input2(57, 194, 330, 24, _("flmsg:"));
                txt_flmsg_pathname->tooltip(_("Enter full path-filename for flmsg"));
                txt_flmsg_pathname->box(FL_DOWN_BOX);
                txt_flmsg_pathname->color((Fl_Color)FL_BACKGROUND2_COLOR);
                txt_flmsg_pathname->selection_color((Fl_Color)FL_SELECTION_COLOR);
                txt_flmsg_pathname->labeltype(FL_NORMAL_LABEL);
                txt_flmsg_pathname->labelfont(0);
                txt_flmsg_pathname->labelsize(14);
                txt_flmsg_pathname->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                txt_flmsg_pathname->callback((Fl_Callback*)cb_txt_flmsg_pathname);
                txt_flmsg_pathname->align(FL_ALIGN_LEFT);
                txt_flmsg_pathname->when(FL_WHEN_CHANGED);
                o->value(progdefaults.flmsg_pathname.c_str());
              } // Fl_Input2* txt_flmsg_pathname
              { btn_select_flmsg = new Fl_Button(390, 194, 100, 24, _("Locate flmsg"));
                btn_select_flmsg->tooltip(_("Locate flmsg executable"));
                btn_select_flmsg->callback((Fl_Callback*)cb_btn_select_flmsg);
              } // Fl_Button* btn_select_flmsg
              { Fl_Check_Button* o = chk_open_flmsg_print = new Fl_Check_Button(259, 163, 136, 20, _("Open in browser"));
                chk_open_flmsg_print->tooltip(_("Open file with default browser"));
                chk_open_flmsg_print->down_box(FL_DOWN_BOX);
                chk_open_flmsg_print->callback((Fl_Callback*)cb_chk_open_flmsg_print);
                o->value(progdefaults.open_flmsg_print);
              } // Fl_Check_Button* chk_open_flmsg_print
              o->end();
            } // Fl_Group* o
            tabNBEMS->end();
          } // Fl_Group* tabNBEMS
          { tabPskmail = new Fl_Group(0, 50, 500, 320, _("Pskmail"));
            tabPskmail->align(FL_ALIGN_TOP_LEFT);
            tabPskmail->hide();
            { Fl_Group* o = new Fl_Group(5, 58, 490, 174, _("Mail Server Attributes"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Counter2* o = cntServerCarrier = new Fl_Counter2(56, 86, 80, 20, _("Carrier frequency (Hz)"));
                cntServerCarrier->tooltip(_("Default listen / transmit frequency"));
                cntServerCarrier->type(1);
                cntServerCarrier->box(FL_UP_BOX);
                cntServerCarrier->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntServerCarrier->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntServerCarrier->labeltype(FL_NORMAL_LABEL);
                cntServerCarrier->labelfont(0);
                cntServerCarrier->labelsize(14);
                cntServerCarrier->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntServerCarrier->minimum(500);
                cntServerCarrier->maximum(2500);
                cntServerCarrier->step(25);
                cntServerCarrier->value(1500);
                cntServerCarrier->callback((Fl_Callback*)cb_cntServerCarrier);
                cntServerCarrier->align(FL_ALIGN_RIGHT);
                cntServerCarrier->when(FL_WHEN_CHANGED);
                o->value(progdefaults.ServerCarrier);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntServerCarrier
              { Fl_Counter2* o = cntServerOffset = new Fl_Counter2(56, 123, 80, 20, _("Search range (Hz)"));
                cntServerOffset->tooltip(_("Listen for signals within this range"));
                cntServerOffset->type(1);
                cntServerOffset->box(FL_UP_BOX);
                cntServerOffset->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntServerOffset->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntServerOffset->labeltype(FL_NORMAL_LABEL);
                cntServerOffset->labelfont(0);
                cntServerOffset->labelsize(14);
                cntServerOffset->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntServerOffset->minimum(10);
                cntServerOffset->maximum(500);
                cntServerOffset->step(10);
                cntServerOffset->value(100);
                cntServerOffset->callback((Fl_Callback*)cb_cntServerOffset);
                cntServerOffset->align(FL_ALIGN_RIGHT);
                cntServerOffset->when(FL_WHEN_CHANGED);
                o->value(progdefaults.SearchRange);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntServerOffset
              { Fl_Counter2* o = cntServerACQsn = new Fl_Counter2(56, 160, 80, 20, _("Acquisition S/N (dB)"));
                cntServerACQsn->tooltip(_("Capture signals over this threshold"));
                cntServerACQsn->type(1);
                cntServerACQsn->box(FL_UP_BOX);
                cntServerACQsn->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntServerACQsn->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntServerACQsn->labeltype(FL_NORMAL_LABEL);
                cntServerACQsn->labelfont(0);
                cntServerACQsn->labelsize(14);
                cntServerACQsn->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntServerACQsn->minimum(3);
                cntServerACQsn->maximum(20);
                cntServerACQsn->step(1);
                cntServerACQsn->value(6);
                cntServerACQsn->callback((Fl_Callback*)cb_cntServerACQsn);
                cntServerACQsn->align(FL_ALIGN_RIGHT);
                cntServerACQsn->when(FL_WHEN_CHANGED);
                o->value(progdefaults.ServerACQsn);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntServerACQsn
              { Fl_Counter2* o = cntServerAFCrange = new Fl_Counter2(56, 197, 80, 20, _("AFC range (Hz)"));
                cntServerAFCrange->tooltip(_("Limit AFC movement to this range"));
                cntServerAFCrange->type(1);
                cntServerAFCrange->box(FL_UP_BOX);
                cntServerAFCrange->color((Fl_Color)FL_BACKGROUND_COLOR);
                cntServerAFCrange->selection_color((Fl_Color)FL_INACTIVE_COLOR);
                cntServerAFCrange->labeltype(FL_NORMAL_LABEL);
                cntServerAFCrange->labelfont(0);
                cntServerAFCrange->labelsize(14);
                cntServerAFCrange->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                cntServerAFCrange->minimum(10);
                cntServerAFCrange->maximum(500);
                cntServerAFCrange->step(10);
                cntServerAFCrange->value(25);
                cntServerAFCrange->callback((Fl_Callback*)cb_cntServerAFCrange);
                cntServerAFCrange->align(FL_ALIGN_RIGHT);
                cntServerAFCrange->when(FL_WHEN_CHANGED);
                o->value(progdefaults.SearchRange);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Counter2* cntServerAFCrange
              { Fl_Check_Button* o = btnPSKmailSweetSpot = new Fl_Check_Button(311, 86, 142, 20, _("Reset to Carrier"));
                btnPSKmailSweetSpot->tooltip(_("When no signal present"));
                btnPSKmailSweetSpot->down_box(FL_DOWN_BOX);
                btnPSKmailSweetSpot->value(1);
                btnPSKmailSweetSpot->callback((Fl_Callback*)cb_btnPSKmailSweetSpot);
                o->value(progdefaults.PSKmailSweetSpot);
              } // Fl_Check_Button* btnPSKmailSweetSpot
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 234, 490, 131, _("General"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btn_arq_s2n_report = new Fl_Check_Button(30, 259, 250, 20, _("Report ARQ frames average S/N"));
                btn_arq_s2n_report->down_box(FL_DOWN_BOX);
                btn_arq_s2n_report->callback((Fl_Callback*)cb_btn_arq_s2n_report);
                o->value(progdefaults.Pskmails2nreport);
              } // Fl_Check_Button* btn_arq_s2n_report
              o->end();
            } // Fl_Group* o
            tabPskmail->end();
          } // Fl_Group* tabPskmail
          { tabSpot = new Fl_Group(0, 50, 500, 320, _("Spotting"));
            tabSpot->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 215, _("PSK Reporter"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { btnPSKRepAuto = new Fl_Check_Button(15, 91, 324, 20, _("Automatically spot callsigns in decoded text"));
                btnPSKRepAuto->tooltip(_("Parse all incoming text"));
                btnPSKRepAuto->down_box(FL_DOWN_BOX);
                btnPSKRepAuto->callback((Fl_Callback*)cb_btnPSKRepAuto);
                btnPSKRepAuto->value(progdefaults.pskrep_auto);
              } // Fl_Check_Button* btnPSKRepAuto
              { btnPSKRepLog = new Fl_Check_Button(15, 121, 327, 20, _("Send reception report when logging a QSO"));
                btnPSKRepLog->tooltip(_("Send report only when QSO is logged"));
                btnPSKRepLog->down_box(FL_DOWN_BOX);
                btnPSKRepLog->callback((Fl_Callback*)cb_btnPSKRepLog);
                btnPSKRepLog->value(progdefaults.pskrep_log);
              } // Fl_Check_Button* btnPSKRepLog
              { btnPSKRepQRG = new Fl_Check_Button(15, 151, 416, 20, _("Report rig frequency (enable only if you have rig control!)"));
                btnPSKRepQRG->tooltip(_("Include the transmit frequency"));
                btnPSKRepQRG->down_box(FL_DOWN_BOX);
                btnPSKRepQRG->callback((Fl_Callback*)cb_btnPSKRepQRG);
                btnPSKRepQRG->value(progdefaults.pskrep_qrg);
              } // Fl_Check_Button* btnPSKRepQRG
              { inpPSKRepHost = new Fl_Input2(56, 191, 220, 24, _("Host:"));
                inpPSKRepHost->tooltip(_("To whom the connection is made"));
                inpPSKRepHost->box(FL_DOWN_BOX);
                inpPSKRepHost->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpPSKRepHost->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpPSKRepHost->labeltype(FL_NORMAL_LABEL);
                inpPSKRepHost->labelfont(0);
                inpPSKRepHost->labelsize(14);
                inpPSKRepHost->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpPSKRepHost->callback((Fl_Callback*)cb_inpPSKRepHost);
                inpPSKRepHost->align(FL_ALIGN_LEFT);
                inpPSKRepHost->when(FL_WHEN_CHANGED);
                inpPSKRepHost->value(progdefaults.pskrep_host.c_str());
                inpPSKRepHost->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpPSKRepHost
              { inpPSKRepPort = new Fl_Input2(425, 191, 60, 24, _("Port:"));
                inpPSKRepPort->tooltip(_("Using UDP port #"));
                inpPSKRepPort->box(FL_DOWN_BOX);
                inpPSKRepPort->color((Fl_Color)FL_BACKGROUND2_COLOR);
                inpPSKRepPort->selection_color((Fl_Color)FL_SELECTION_COLOR);
                inpPSKRepPort->labeltype(FL_NORMAL_LABEL);
                inpPSKRepPort->labelfont(0);
                inpPSKRepPort->labelsize(14);
                inpPSKRepPort->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                inpPSKRepPort->callback((Fl_Callback*)cb_inpPSKRepPort);
                inpPSKRepPort->align(FL_ALIGN_LEFT);
                inpPSKRepPort->when(FL_WHEN_CHANGED);
                inpPSKRepPort->value(progdefaults.pskrep_port.c_str());
                inpPSKRepPort->labelsize(FL_NORMAL_SIZE);
              } // Fl_Input2* inpPSKRepPort
              { btnPSKRepInit = new Fl_Button(405, 236, 80, 24, _("Initialize"));
                btnPSKRepInit->tooltip(_("Initialize the socket client"));
                btnPSKRepInit->callback((Fl_Callback*)cb_btnPSKRepInit);
              } // Fl_Button* btnPSKRepInit
              { boxPSKRepMsg = new Fl_Box(15, 220, 300, 48, _("<PSK Reporter error message>"));
                boxPSKRepMsg->labelfont(2);
                boxPSKRepMsg->label(0);
              } // Fl_Box* boxPSKRepMsg
              o->end();
            } // Fl_Group* o
            tabSpot->end();
          } // Fl_Group* tabSpot
          { tabSweetSpot = new Fl_Group(0, 50, 500, 320, _("Sweet Spot"));
            tabSweetSpot->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 490, 75);
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Value_Input2* o = valCWsweetspot = new Fl_Value_Input2(42, 71, 65, 20, _("CW"));
                valCWsweetspot->tooltip(_("Default CW tracking point"));
                valCWsweetspot->box(FL_DOWN_BOX);
                valCWsweetspot->color((Fl_Color)FL_BACKGROUND2_COLOR);
                valCWsweetspot->selection_color((Fl_Color)FL_SELECTION_COLOR);
                valCWsweetspot->labeltype(FL_NORMAL_LABEL);
                valCWsweetspot->labelfont(0);
                valCWsweetspot->labelsize(14);
                valCWsweetspot->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valCWsweetspot->minimum(200);
                valCWsweetspot->maximum(4000);
                valCWsweetspot->step(1);
                valCWsweetspot->value(1000);
                valCWsweetspot->callback((Fl_Callback*)cb_valCWsweetspot);
                valCWsweetspot->align(FL_ALIGN_LEFT);
                valCWsweetspot->when(FL_WHEN_CHANGED);
                o->value(progdefaults.CWsweetspot);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* valCWsweetspot
              { Fl_Value_Input2* o = valRTTYsweetspot = new Fl_Value_Input2(220, 71, 65, 20, _("RTTY"));
                valRTTYsweetspot->tooltip(_("Default RTTY tracking point"));
                valRTTYsweetspot->box(FL_DOWN_BOX);
                valRTTYsweetspot->color((Fl_Color)FL_BACKGROUND2_COLOR);
                valRTTYsweetspot->selection_color((Fl_Color)FL_SELECTION_COLOR);
                valRTTYsweetspot->labeltype(FL_NORMAL_LABEL);
                valRTTYsweetspot->labelfont(0);
                valRTTYsweetspot->labelsize(14);
                valRTTYsweetspot->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valRTTYsweetspot->minimum(200);
                valRTTYsweetspot->maximum(4000);
                valRTTYsweetspot->step(1);
                valRTTYsweetspot->value(1000);
                valRTTYsweetspot->callback((Fl_Callback*)cb_valRTTYsweetspot);
                valRTTYsweetspot->align(FL_ALIGN_LEFT);
                valRTTYsweetspot->when(FL_WHEN_CHANGED);
                o->value(progdefaults.RTTYsweetspot);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* valRTTYsweetspot
              { Fl_Value_Input2* o = valPSKsweetspot = new Fl_Value_Input2(420, 71, 65, 20, _("PSK et al."));
                valPSKsweetspot->tooltip(_("Default for all other modems"));
                valPSKsweetspot->box(FL_DOWN_BOX);
                valPSKsweetspot->color((Fl_Color)FL_BACKGROUND2_COLOR);
                valPSKsweetspot->selection_color((Fl_Color)FL_SELECTION_COLOR);
                valPSKsweetspot->labeltype(FL_NORMAL_LABEL);
                valPSKsweetspot->labelfont(0);
                valPSKsweetspot->labelsize(14);
                valPSKsweetspot->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
                valPSKsweetspot->minimum(200);
                valPSKsweetspot->maximum(4000);
                valPSKsweetspot->step(1);
                valPSKsweetspot->value(1000);
                valPSKsweetspot->callback((Fl_Callback*)cb_valPSKsweetspot);
                valPSKsweetspot->align(FL_ALIGN_LEFT);
                valPSKsweetspot->when(FL_WHEN_CHANGED);
                o->value(progdefaults.PSKsweetspot);
                o->labelsize(FL_NORMAL_SIZE);
              } // Fl_Value_Input2* valPSKsweetspot
              { Fl_Check_Button* o = btnStartAtSweetSpot = new Fl_Check_Button(15, 101, 348, 20, _("Always start new modems at these frequencies"));
                btnStartAtSweetSpot->tooltip(_("ON - start at default\nOFF - keep current wf cursor position"));
                btnStartAtSweetSpot->down_box(FL_DOWN_BOX);
                btnStartAtSweetSpot->value(1);
                btnStartAtSweetSpot->callback((Fl_Callback*)cb_btnStartAtSweetSpot);
                o->value(progdefaults.StartAtSweetSpot);
              } // Fl_Check_Button* btnStartAtSweetSpot
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 140, 490, 60, _("K3 A1A configuation"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnCWIsLSB = new Fl_Check_Button(220, 161, 70, 15, _("CW is LSB"));
                btnCWIsLSB->tooltip(_("Select this for Elecraft K3\nOther radios should not need it."));
                btnCWIsLSB->down_box(FL_DOWN_BOX);
                btnCWIsLSB->callback((Fl_Callback*)cb_btnCWIsLSB);
                o->value(progdefaults.CWIsLSB);
              } // Fl_Check_Button* btnCWIsLSB
              o->end();
            } // Fl_Group* o
            tabSweetSpot->end();
          } // Fl_Group* tabSweetSpot
          { tabText_IO = new Fl_Group(0, 50, 500, 320, _("Text i/o"));
            tabText_IO->hide();
            { grpTalker = new Fl_Group(5, 117, 490, 73, _("Talker Socket (MS only)"));
              grpTalker->box(FL_ENGRAVED_FRAME);
              grpTalker->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { btnConnectTalker = new Fl_Light_Button(31, 137, 74, 20, _("Talker"));
                btnConnectTalker->selection_color((Fl_Color)FL_DARK_GREEN);
                btnConnectTalker->callback((Fl_Callback*)cb_btnConnectTalker);
              } // Fl_Light_Button* btnConnectTalker
              { Fl_Box* o = new Fl_Box(110, 137, 345, 20, _("Connect/disconnect to Talker socket server"));
                o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
              } // Fl_Box* o
              { Fl_Check_Button* o = btn_auto_talk = new Fl_Check_Button(31, 165, 391, 15, _("Auto connect when fldigi opens (server must be up)"));
                btn_auto_talk->down_box(FL_DOWN_BOX);
                btn_auto_talk->callback((Fl_Callback*)cb_btn_auto_talk);
                o->value(progdefaults.auto_talk);
              } // Fl_Check_Button* btn_auto_talk
              grpTalker->end();
            } // Fl_Group* grpTalker
            { Fl_Group* o = new Fl_Group(5, 57, 490, 56, _("Capture rx text to external file"));
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chkRxStream = new Fl_Check_Button(31, 84, 175, 20, _("Enable rx text stream"));
                chkRxStream->tooltip(_("Send rx text to file: textout.txt"));
                chkRxStream->down_box(FL_DOWN_BOX);
                chkRxStream->callback((Fl_Callback*)cb_chkRxStream);
                o->value(progdefaults.speak);
              } // Fl_Check_Button* chkRxStream
              o->end();
            } // Fl_Group* o
            tabText_IO->end();
          } // Fl_Group* tabText_IO
          tabsMisc->end();
        } // Fl_Tabs* tabsMisc
        tabMisc->end();
      } // Fl_Group* tabMisc
      { tabQRZ = new Fl_Group(0, 25, 500, 345, _("Callsign DB"));
        tabQRZ->tooltip(_("Callsign database"));
        tabQRZ->hide();
        { Fl_Group* o = new Fl_Group(5, 180, 490, 75, _("CDROM"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Round_Button* o = btnQRZcdrom = new Fl_Round_Button(25, 215, 70, 20, _("QRZ"));
            btnQRZcdrom->tooltip(_("Use CD or hard drive CD image"));
            btnQRZcdrom->down_box(FL_DOWN_BOX);
            btnQRZcdrom->callback((Fl_Callback*)cb_btnQRZcdrom);
            o->value(progdefaults.QRZ == QRZCD);
          } // Fl_Round_Button* btnQRZcdrom
          { Fl_Input2* o = txtQRZpathname = new Fl_Input2(104, 215, 300, 20, _("at:"));
            txtQRZpathname->tooltip(_("ie: /home/dave/CALLBK/ or C:/CALLBK/\nLeave blank to search for database"));
            txtQRZpathname->box(FL_DOWN_BOX);
            txtQRZpathname->color((Fl_Color)FL_BACKGROUND2_COLOR);
            txtQRZpathname->selection_color((Fl_Color)FL_SELECTION_COLOR);
            txtQRZpathname->labeltype(FL_NORMAL_LABEL);
            txtQRZpathname->labelfont(0);
            txtQRZpathname->labelsize(14);
            txtQRZpathname->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            txtQRZpathname->callback((Fl_Callback*)cb_txtQRZpathname);
            txtQRZpathname->align(FL_ALIGN_LEFT);
            txtQRZpathname->when(FL_WHEN_RELEASE);
            o->value(progdefaults.QRZpathname.c_str());
            txtQRZpathname->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* txtQRZpathname
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(5, 260, 490, 95, _("Paid online subscription"));
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Round_Button* o = btnQRZsub = new Fl_Round_Button(25, 291, 90, 20, _("QRZ.com"));
            btnQRZsub->tooltip(_("You need a paid QRZ online\nsubscription to access"));
            btnQRZsub->down_box(FL_DOWN_BOX);
            btnQRZsub->callback((Fl_Callback*)cb_btnQRZsub);
            o->value(progdefaults.QRZ == QRZNET);
          } // Fl_Round_Button* btnQRZsub
          { Fl_Round_Button* o = btnHamcall = new Fl_Round_Button(25, 321, 105, 20, _("Hamcall.net"));
            btnHamcall->tooltip(_("You need a paid Hamcall online\nsubscription to access"));
            btnHamcall->down_box(FL_DOWN_BOX);
            btnHamcall->callback((Fl_Callback*)cb_btnHamcall);
            o->value(progdefaults.QRZ == HAMCALLNET);
          } // Fl_Round_Button* btnHamcall
          { Fl_Input2* o = inpQRZusername = new Fl_Input2(235, 291, 90, 20, _("User name"));
            inpQRZusername->tooltip(_("Your login name"));
            inpQRZusername->box(FL_DOWN_BOX);
            inpQRZusername->color((Fl_Color)FL_BACKGROUND2_COLOR);
            inpQRZusername->selection_color((Fl_Color)FL_SELECTION_COLOR);
            inpQRZusername->labeltype(FL_NORMAL_LABEL);
            inpQRZusername->labelfont(0);
            inpQRZusername->labelsize(14);
            inpQRZusername->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            inpQRZusername->callback((Fl_Callback*)cb_inpQRZusername);
            inpQRZusername->align(FL_ALIGN_LEFT);
            inpQRZusername->when(FL_WHEN_RELEASE);
            o->value(progdefaults.QRZusername.c_str());
            inpQRZusername->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* inpQRZusername
          { Fl_Input2* o = inpQRZuserpassword = new Fl_Input2(236, 321, 90, 20, _("Password"));
            inpQRZuserpassword->tooltip(_("Your login password"));
            inpQRZuserpassword->box(FL_DOWN_BOX);
            inpQRZuserpassword->color((Fl_Color)FL_BACKGROUND2_COLOR);
            inpQRZuserpassword->selection_color((Fl_Color)FL_SELECTION_COLOR);
            inpQRZuserpassword->labeltype(FL_NORMAL_LABEL);
            inpQRZuserpassword->labelfont(0);
            inpQRZuserpassword->labelsize(14);
            inpQRZuserpassword->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
            inpQRZuserpassword->callback((Fl_Callback*)cb_inpQRZuserpassword);
            inpQRZuserpassword->align(FL_ALIGN_LEFT);
            inpQRZuserpassword->when(FL_WHEN_RELEASE);
            o->value(progdefaults.QRZuserpassword.c_str());
            o->type(FL_SECRET_INPUT);
            inpQRZuserpassword->labelsize(FL_NORMAL_SIZE);
          } // Fl_Input2* inpQRZuserpassword
          { btnQRZpasswordShow = new Fl_Button(336, 321, 70, 20, _("Show"));
            btnQRZpasswordShow->tooltip(_("Show password in plain text"));
            btnQRZpasswordShow->callback((Fl_Callback*)cb_btnQRZpasswordShow);
          } // Fl_Button* btnQRZpasswordShow
          o->end();
        } // Fl_Group* o
        { Fl_Group* o = new Fl_Group(5, 35, 490, 140);
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Round_Button* o = btnQRZnotavailable = new Fl_Round_Button(25, 45, 337, 20, _("Not available"));
            btnQRZnotavailable->tooltip(_("Do not use callsign database"));
            btnQRZnotavailable->down_box(FL_DOWN_BOX);
            btnQRZnotavailable->value(1);
            btnQRZnotavailable->callback((Fl_Callback*)cb_btnQRZnotavailable);
            o->value(progdefaults.QRZ == QRZNONE);
          } // Fl_Round_Button* btnQRZnotavailable
          { Fl_Round_Button* o = btnQRZonline = new Fl_Round_Button(25, 75, 337, 20, _("QRZ online via default Internet Browser"));
            btnQRZonline->tooltip(_("Visit QRZ web site"));
            btnQRZonline->down_box(FL_DOWN_BOX);
            btnQRZonline->callback((Fl_Callback*)cb_btnQRZonline);
            o->value(progdefaults.QRZ == QRZHTML);
          } // Fl_Round_Button* btnQRZonline
          { Fl_Round_Button* o = btnHAMCALLonline = new Fl_Round_Button(25, 106, 337, 20, _("HamCall online via default Internet Browser"));
            btnHAMCALLonline->tooltip(_("Visit Hamcall web site"));
            btnHAMCALLonline->down_box(FL_DOWN_BOX);
            btnHAMCALLonline->callback((Fl_Callback*)cb_btnHAMCALLonline);
            o->value(progdefaults.QRZ == HAMCALLHTML);
          } // Fl_Round_Button* btnHAMCALLonline
          { Fl_Round_Button* o = btnCALLOOK = new Fl_Round_Button(25, 137, 337, 20, _("Callook.info lookup (US callsigns only)"));
            btnCALLOOK->tooltip(_("Visit Hamcall web site"));
            btnCALLOOK->down_box(FL_DOWN_BOX);
            btnCALLOOK->callback((Fl_Callback*)cb_btnCALLOOK);
            o->value(progdefaults.QRZ == CALLOOK);
          } // Fl_Round_Button* btnCALLOOK
          o->end();
        } // Fl_Group* o
        tabQRZ->end();
      } // Fl_Group* tabQRZ
      tabsConfigure->end();
    } // Fl_Tabs* tabsConfigure
    { btnSaveConfig = new Fl_Button(235, 375, 130, 22, _("Save"));
      btnSaveConfig->callback((Fl_Callback*)cb_btnSaveConfig);
    } // Fl_Button* btnSaveConfig
    { btnCloseConfig = new Fl_Return_Button(367, 375, 130, 22, _("Close"));
      btnCloseConfig->callback((Fl_Callback*)cb_btnCloseConfig);
    } // Fl_Return_Button* btnCloseConfig
    { btnResetConfig = new Fl_Button(5, 375, 130, 22, _("Restore defaults"));
      btnResetConfig->callback((Fl_Callback*)cb_btnResetConfig);
    } // Fl_Button* btnResetConfig
    o->set_non_modal();
    o->end();
  } // Fl_Double_Window* o
  return w;
}

void openConfig() {
  if (!dlgConfig) createConfig();
progdefaults.loadDefaults();
}

void closeDialog() {
  if (dlgConfig) dlgConfig->hide();
}

void createConfig() {
  if (!dlgConfig) {
    dlgConfig = ConfigureDialog();
    dlgConfig->xclass(PACKAGE_NAME);
  }
}
